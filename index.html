<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sistema Solar ‚Äî √çndice de Peligro "D" y Simulador de Impacto</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<style>
    /* --- ESTILOS DE MONTECARLO_ORBITAL (BASE) --- */
    :root{
        --ui-bg-color: rgba(10, 15, 20, 0.6);
        --ui-border-color: rgba(100, 150, 200, 0.3);
        --text-color-primary:#e0e5f0;
        --text-color-secondary:#9cb3d1;
        --accent-color:#38a9ff;
        --danger-color:#ff4d6d;
        --warning-color:#ffc107;
        --safe-color:#00ff88;
        --live-color:#00ff88;
    }
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');
    html,body{ margin:0; height:100%; background:#000; color:var(--text-color-primary); font-family:'Roboto',system-ui,-apple-system,Segoe UI,Arial,sans-serif; overflow:hidden;}
    .ui-panel{ background:var(--ui-bg-color); border:1px solid var(--ui-border-color);
        backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        border-radius:8px; padding:12px; box-shadow:0 4px 20px rgba(0,0,0,0.2); z-index:100;}
    #top-left-hud{ position:absolute; top:20px; left:20px; width:360px; max-height: calc(100% - 40px); display:flex; flex-direction:column;}
    #top-right-hud{ position:absolute; top:20px; right:20px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    #bottom-center-hud{ position:absolute; bottom:0; left:50%; transform:translateX(-50%); }
    
    /* MODIFICACI√ìN: A√±adido max-height y overflow-y para el scroll */
    #left-controls{ 
        position:absolute; 
        left:20px; 
        bottom:20px; 
        width:420px; 
        display:flex; 
        flex-direction:column; 
        gap:10px;
        max-height: calc(100vh - 60px); /* L√≠mite de altura */
        overflow-y: auto; /* Scrollbar vertical si es necesario */
        padding-right: 5px; /* Peque√±o espacio para el scrollbar */
    }

    /* MODIFICACI√ìN: Estilos para el nuevo scrollbar */
    #left-controls::-webkit-scrollbar { width: 8px; }
    #left-controls::-webkit-scrollbar-track { background: transparent; }
    #left-controls::-webkit-scrollbar-thumb { 
        background-color: var(--accent-color); 
        border-radius: 4px; 
        border: 2px solid rgba(10, 15, 20, 0.6); 
    }

    #selection-info h3{ margin:0 0 8px 0; color:var(--accent-color); font-size:1.2em;}
    #selection-info p{ margin:4px 0; font-size:.9em; color:var(--text-color-secondary);}
    #selection-info .valor{ color:var(--text-color-primary); font-weight:700;}
    #selection-info-details{ flex-grow:1; overflow-y:auto; margin-top: 10px; padding-right: 5px; }
    #selection-info-details::-webkit-scrollbar { width: 8px; }
    #selection-info-details::-webkit-scrollbar-track { background: var(--ui-bg-color); border-radius: 4px; }
    #selection-info-details::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 4px; border: 2px solid var(--ui-bg-color); }

    button{
        padding:9px 12px; background:rgba(56,169,255,.2); border:1px solid var(--accent-color);
        color:var(--text-color-primary); border-radius:6px; cursor:pointer; font-weight:500; transition:.2s; font-size:.9em;
    }
    button:hover{ background:rgba(56,169,255,.4); border-color:#fff;}
    #body-selector{
        background:rgba(0,0,0,.3); color:var(--text-color-primary);
        padding:9px; border-radius:6px; border:1px solid var(--ui-border-color);
        min-width:200px; font-size:.9em;
    }
    #nasa-panel{ position:fixed; top:0; right:-480px; width:460px; height:100vh; display:flex; flex-direction:column;
        transition:right .4s ease-in-out; border-left:2px solid var(--accent-color);}
    #nasa-panel.open{ right:0; }
    #nasa-header{ padding:14px 18px; background:rgba(0,0,0,.2); display:flex; justify-content:space-between; align-items:center;}
    #nasa-header h2{ color:var(--warning-color); margin:0; font-size:1.05em;}
    #nasa-content{ overflow-y:auto; padding:14px; flex-grow:1; }
    #nasa-status{ text-align:center; font-size:.95em; padding:10px; color:var(--warning-color); font-style:italic;}
    .asteroide-card{
        background:rgba(0,0,0,.2); border-left:4px solid var(--accent-color); border-radius:6px;
        padding:12px; margin-bottom:10px; cursor:pointer; transition:.2s;
    }
    .asteroide-card:hover{ background:rgba(56,169,255,.15); transform:translateX(-5px);}
    .asteroide-card.peligroso{ border-left-color:var(--danger-color);}
    .asteroide-card h3{ margin:0 0 6px 0; color:#fff; font-size:1em;}
    .asteroide-card p{ margin:3px 0; color:var(--text-color-secondary); font-size:.85em;}
    .asteroide-card strong{ color:var(--warning-color); font-weight:500;}
    #time-controls{ display:flex; align-items:center; gap:10px; padding:8px 16px; margin-bottom:10px;}
    .time-btn{ background:none; border:none; color:var(--text-color-primary); cursor:pointer; padding:4px; display:flex; align-items:center; justify-content:center;}
    .time-btn svg { width: 22px; height: 22px; }
    .time-btn:hover{ color:var(--accent-color);}
    #date-display{ font-size:1.05em; font-weight:500; min-width:260px; text-align:center;}
    #live-btn{ font-size:.8em; font-weight:700; padding:7px 10px;}
    #live-indicator{ display:inline-flex; align-items:center; color:var(--live-color); font-weight:bold; margin-left:8px;}
    #live-indicator::before{ content:''; width:8px; height:8px; background:var(--live-color); border-radius:50%; margin-right:6px; box-shadow:0 0 6px var(--live-color);}
    .row{ display:flex; align-items:center; gap:10px; }
    .col{ display:flex; flex-direction:column; gap:6px; }
    .label{ font-size:.9em; color:var(--text-color-secondary); }
    input[type="range"]{ flex-grow: 1; background:transparent; }
    input[type="range"]::-webkit-slider-runnable-track{ height:3px; background:rgba(255,255,255,.2); border-radius:2px;}
    input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; height:16px; width:16px; background:var(--accent-color); border-radius:50%; margin-top:-6.5px;}
    .switches{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 14px; }
    .switches label{ font-size:.9em; color:var(--text-color-secondary); display:flex; align-items:center; gap:6px; cursor:pointer;}
    .small{ font-size:.85em; color:var(--text-color-secondary); }
    .filters{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .filters label{ display:flex; align-items:center; gap:6px; cursor:pointer; font-size:.9em; color:var(--text-color-secondary);}

    .label3d {
        color: var(--text-color-primary); font-size: 14px; font-weight: 500;
        white-space: nowrap; pointer-events: none; transform: translate(-50%, -150%);
        text-shadow: 0 0 6px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.3s ease-in-out;
    }
    .label3d.visible { opacity: 1; }

    #selection-mini-map {
        width: 100px; height: 100px; background-color: transparent; border: none;
        margin: 10px auto 0; display: flex; justify-content: center; align-items: center;
        overflow: hidden; position: relative;
    }
    #selection-mini-map img.circle { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }
    #selection-mini-map img.irregular { max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 0; transform: scale(0.9); }
    #selection-mini-map .symbol { font-size: 4em; line-height: 1; color: var(--accent-color); }
    
    .value-display {
        font-size: 0.9em; color: var(--text-color-primary); font-weight: 500;
        min-width: 65px; text-align: right; padding-right: 5px;
    }

    .meteor-selector {
        width: 100%; padding: 10px 12px; background: rgba(0,0,0,0.3); 
        color: var(--text-color-primary); border: 1px solid var(--ui-border-color);
        border-radius: 6px; font-size: 0.9em; cursor: pointer;
        transition: all 0.2s ease; appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 8px center; background-repeat: no-repeat; background-size: 16px;
        padding-right: 32px;
    }
    .meteor-selector:hover { border-color: var(--accent-color); background-color: rgba(56,169,255,0.1); }
    .meteor-selector:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 2px rgba(56,169,255,0.2); }
    .meteor-selector option { background: rgba(10,15,20,0.95); color: var(--text-color-primary); padding: 8px; }

    .action-btn {
        padding: 6px 10px; background: rgba(56,169,255,0.2); border: 1px solid var(--accent-color);
        color: var(--text-color-primary); border-radius: 4px; cursor: pointer; font-size: 0.8em;
        transition: all 0.2s ease; display: flex; align-items: center; gap: 4px;
        font-weight: 500;
    }
    .action-btn:hover { background: rgba(56,169,255,0.4); border-color: #fff; transform: translateY(-1px); }
    .action-btn:disabled { opacity: 0.5; cursor: not-allowed; background: rgba(100,100,100,0.2); border-color: #666; }
    .action-btn:disabled:hover { transform: none; }
    .refresh-btn { background: rgba(255,193,7,0.2); border-color: var(--warning-color); }
    .refresh-btn:hover { background: rgba(255,193,7,0.4); }
    .plot-btn { background: rgba(0,255,136,0.2); border-color: var(--safe-color); }
    .plot-btn:hover { background: rgba(0,255,136,0.4); }
    .meteor-info { animation: slideDown 0.3s ease-out; }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    .plot-container { animation: fadeIn 0.4s ease-out; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .close-btn:hover { color: var(--danger-color); transform: scale(1.1); }
    #prediction-panel { display: flex; flex-direction: column; gap: 10px; }
    #prediction-panel input[type="datetime-local"], #prediction-panel select {
        width: 100%;
        padding: 8px;
        background: rgba(0,0,0,0.3);
        color: var(--text-color-primary);
        border: 1px solid var(--ui-border-color);
        border-radius: 4px;
        font-family: inherit;
        font-size: 0.9em;
    }
    #prediction-results {
        margin-top: 10px;
        padding: 10px;
        background: rgba(0,0,0,0.2);
        border-left: 3px solid var(--safe-color);
        border-radius: 4px;
        font-size: 0.85em;
        line-height: 1.5;
        min-height: 100px;
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    #impact-sim-button{
        margin-top: 10px;
        width: 100%;
        background: var(--danger-color);
        border-color: #fff;
        font-weight: bold;
    }
    #impact-sim-button:hover{
        background: #fff;
        color: var(--danger-color);
    }
    
    /* --- ESTILOS DE ASTEROIDEFINAL (AISLADOS Y CORREGIDOS) --- */
    .hidden { display: none !important; }

    #map-container { 
        position: fixed; 
        top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.7); 
        z-index: 1000; 
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Familia de fuente espec√≠fica */
    }
    #map-wrapper { 
        width: 90%; height: 90%; 
        position: absolute; top: 50%; left: 50%; 
        transform: translate(-50%, -50%); 
        box-shadow: 0 0 25px black; 
    }
    #map { width: 100%; height: 100%; background: #000; }

    /* Estilo espec√≠fico para los paneles DENTRO del mapa para evitar conflictos */
    #map-container .ui-panel {
        position: absolute;
        background: rgba(29, 41, 59, 0.9);
        border: 1px solid #374151;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        backdrop-filter: blur(5px);
        z-index: 1011;
    }

    #close-map-btn { 
        position: absolute; 
        top: 15px; right: 15px;
        z-index: 1012; 
        background: none; border: none;
        color: #9ca3af;
        font-size: 2.2em;
        cursor: pointer; 
        width: auto; padding: 0;
        line-height: 1; text-align: center;
        transition: color 0.2s;
    }
    #close-map-btn:hover { 
        background: none;
        color: #d1d5db;
    }
    #map-info { 
        bottom: 10px; left: 50%; 
        transform: translateX(-50%); 
        color: #d1d5db;
    }
    #layer-toggle-panel { 
        top: 20px; left: 20px; width: 200px; 
    }
    #layer-toggle-panel h3 {
        font-size: 1em;
        color: #3b82f6; /* accent-color from asteroidefinal */
        margin: 0 0 10px 0;
        padding: 0;
        text-shadow: none;
        font-weight: 600;
    }
    #layer-toggle-panel select {
        background-color: #1f2937;
        color: #d1d5db;
        border: 1px solid #374151;
        border-radius: 5px;
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
    }
    #impact-results-panel {
        top: 20px; right: 20px; width: 300px; 
        max-height: calc(100% - 40px); overflow-y: auto;
    }
    #impact-results-panel hr { border: 0; border-top: 1px solid #374151; margin: 12px 0; }
    
    /* Estilos para el contenido del panel de resultados */
    #impact-results-panel h3 { 
        font-size: 1.1em; 
        text-align: center; 
        border-bottom: 1px solid #374151; 
        padding-bottom: 10px;
        margin: 0 0 15px 0;
        color: #fff;
        font-weight: 600;
        text-shadow: none;
    }
    #impact-results-panel .data-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9em; }
    #impact-results-panel .data-label { color: #9ca3af; }
    #impact-results-panel .data-value { font-weight: bold; color: #d1d5db; text-align: right; }
</style>
</head>
<body>
    <div id="top-left-hud" class="ui-panel">
        <div id="selection-info">
            <h3 id="selection-name"></h3>
            <div id="selection-mini-map"></div>
        </div>
        <div id="selection-info-details"></div>
        <div class="row" style="margin-top:auto; padding-top:8px; align-items:center;">
            <label style="display:flex; align-items:center; gap:6px;">
                <input type="checkbox" id="follow-toggle" checked>
                Seguir selecci√≥n (anclar c√°mara al objetivo)
            </label>
        </div>
    </div>

    <div id="top-right-hud">
        <select id="body-selector" class="ui-panel"></select>
        <button id="toggle-nasa-panel-btn">Asteroides ‚òÑ</button>
        <button id="show-all-now-btn" title="Mostrar todos de golpe">Mostrar TODOS</button>
    </div>

    <div id="bottom-center-hud">
        <div id="time-controls" class="ui-panel">
            <button class="time-btn" id="rewind-btn" title="Retroceder"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M11 18V6l-8.5 6 8.5 6zm-8.5-6L11 6v12l-8.5-6zM20 6l-8.5 6 8.5 6V6z"/></svg></button>
            <button class="time-btn" id="play-pause-btn" title="Pausar/Reanudar"><svg class="icon-pause" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M14 19h4V5h-4v14zm-8 0h4V5H6v14z"/></svg><svg class="icon-play" style="display:none;" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg></button>
            <button class="time-btn" id="fast-forward-btn" title="Adelantar"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg></button>
            <div id="date-display"></div>
            <button id="live-btn">LIVE</button>
        </div>
    </div>

    <div id="nasa-panel" class="ui-panel">
        <div id="nasa-header">
            <h2>Asteroides Cercanos</h2>
            <button id="close-nasa-panel">&times;</button>
        </div>
        <div id="nasa-content">
            <div class="filters" style="margin-bottom:10px;">
                <label><input type="checkbox" id="filter-only-pha"> Solo peligrosos (PHA)</label>
                <label><input type="checkbox" id="filter-hide-nonpha"> Ocultar no peligrosos</label>
                <label title="Aplica un brillo intenso a los asteroides para facilitar su visualizaci√≥n"><input type="checkbox" id="asteroid-glow-toggle"> Brillo Intenso</label>
            </div>
            <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:wrap;">
                <select id="asteroid-visual-mode" title="Modo de visualizaci√≥n"><option value="single">Uno por uno</option><option value="all">Todos</option></select>
                <button id="draw-all-orbits-btn" title="Dibujar √≥rbitas de todos">Dibujar todas las √≥rbitas</button>
                <button id="clear-asteroids-btn" title="Eliminar asteroides">Limpiar asteroides</button>
            </div>
            <div id="contenedor-asteroides">
                <div class="asteroide-card" id="show-creation-card" style="border-left-color: var(--warning-color);"><h3>+ Crear Asteroide Simulado</h3></div>
            </div>
            <div id="creation-controls-wrapper" style="display:none; padding:10px;">
                <button id="back-to-list-btn" style="margin-bottom: 12px;">&larr; Volver</button>
                <h2 style="text-align:center; border-bottom:1px solid var(--ui-border-color); padding-bottom:6px;">Lanzar Asteroide Simulado</h2>
                <div class="col" style="gap: 8px; margin-top: 10px;">
                    <h4 style="color:var(--accent-color); margin:0 0 8px 0; font-size:0.9em;">üìê Par√°metros Orbitales Keplerianos</h4>
                    
                    <div class="row"><span class="label" style="width:100px;">Semieje Mayor (a)</span><input type="range" id="semiMajorAxis" min="0.5" max="3.0" value="1.2" step="0.01"><span class="value-display" id="semiMajorAxis-value"></span></div>
                    <div class="row"><span class="label" style="width:100px;">Excentricidad (e)</span><input type="range" id="eccentricity" min="0" max="0.9" value="0.3" step="0.01"><span class="value-display" id="eccentricity-value"></span></div>
                    <div class="row"><span class="label" style="width:100px;">Inclinaci√≥n (i)</span><input type="range" id="inclination" min="0" max="180" value="15" step="1"><span class="value-display" id="inclination-value"></span></div>
                    <div class="row"><span class="label" style="width:100px;">Long. Nodo (Œ©)</span><input type="range" id="longitudeNode" min="0" max="360" value="45" step="1"><span class="value-display" id="longitudeNode-value"></span></div>
                    <div class="row"><span class="label" style="width:100px;">Arg. Perihelio (œâ)</span><input type="range" id="argumentPerihelion" min="0" max="360" value="90" step="1"><span class="value-display" id="argumentPerihelion-value"></span></div>
                    <div class="row"><span class="label" style="width:100px;">Anomal√≠a Media (M)</span><input type="range" id="meanAnomaly" min="0" max="360" value="180" step="1"><span class="value-display" id="meanAnomaly-value"></span></div>
                    
                    <hr style="border:none; border-top:1px solid var(--ui-border-color); opacity:.5; margin:8px 0;">
                    
                    <h4 style="color:var(--accent-color); margin:0 0 8px 0; font-size:0.9em;">üåç Propiedades F√≠sicas</h4>
                    <div class="row"><span class="label" style="width:100px;">Di√°metro</span><input type="range" id="diameter" min="10" max="2000" value="150" step="5"><span class="value-display" id="diameter-value"></span></div>
                    
                    <div id="orbital-info" style="margin-top:8px; padding: 8px; background:rgba(56,169,255,0.1); border-radius: 4px; font-size:0.85em;">
                <div style="color:var(--accent-color); font-weight:600; margin-bottom:4px;">üìä Informaci√≥n Orbital</div>
                            <div id="orbital-details" style="color:var(--text-color-secondary);"></div>
                    </div>
                    
                    <div id="danger-assessment-minimal" style="margin-top:10px; padding: 8px; border-radius: 4px; text-align:center; font-weight:bold; transition: all 0.2s;"></div>
                    <button id="launchAsteroid" style="margin-top:12px; width:100%;">üöÄ Lanzar Asteroide</button>
                </div>
            </div>
            <div id="asteroidList" style="display:grid; gap:10px; margin-top:10px;"></div>
            <div id="nasa-status">Cargando datos...</div>
        </div>
    </div>

    <div id="left-controls" class="ui-panel">
        <div class="col">
            <div class="label">Velocidad del tiempo</div>
            <input id="time-speed" type="range" min="0" max="12" value="10" step="1" />
            <div class="small" id="time-speed-label">x1.0 d/s</div>
        </div>
        <hr style="border:none; border-top:1px solid var(--ui-border-color); opacity:.5;">
        <div class="col">
            <div class="label" style="margin-bottom:4px;">Visibilidad</div>
            <div class="switches">
                <label><input type="checkbox" id="vis-sun" checked> Sol</label>
                <label><input type="checkbox" id="vis-planets" checked> Planetas</label>
                <label><input type="checkbox" id="vis-earth" checked> Tierra</label>
                <label><input type="checkbox" id="vis-moon" checked> Luna</label>
                <label><input type="checkbox" id="vis-planet-orbits" checked> √ìrbitas planetas</label>
                <label><input type="checkbox" id="vis-earth-orbit" checked> √ìrbita Tierra</label>
                <label><input type="checkbox" id="vis-ast-orbits" checked> √ìrbitas asteroides</label>
                <label><input type="checkbox" id="vis-ast-markers" checked> Marcadores asteroides</label>
                <label><input type="checkbox" id="vis-labels" checked> Etiquetas</label>
            </div>
        </div>
        <hr style="border:none; border-top:1px solid var(--ui-border-color); opacity:.5;">
        <div class="col">
            <div class="collapsible-header" id="distance-analysis-header" style="display:flex; align-items:center; gap:8px; margin-bottom:8px; cursor:pointer; padding:8px; background:rgba(56,169,255,0.1); border-radius:6px; transition:all 0.2s ease;" onclick="toggleDistanceAnalysis()">
                <div class="label" style="font-weight:600; color:var(--accent-color); flex:1;">üìä An√°lisis de Distancia</div>
                <div class="collapse-icon" id="distance-analysis-icon" style="font-size:1.2em; color:var(--accent-color); transition:transform 0.2s ease;">‚ñº</div>
            </div>
            
            <div class="meteor-selector-container" id="distance-analysis-content" style="margin-bottom:12px; display:none;">
                <div class="selector-header" style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <label class="selector-label" style="font-size:0.9em; color:var(--text-color-secondary);">Meteoro:</label>
                    <div class="selector-status" id="meteor-status" style="font-size:0.8em; color:var(--warning-color);">Cargando...</div>
                </div>
                <div class="selector-wrapper" style="position:relative;">
                    <select id="meteor-selector" class="meteor-selector" title="Seleccionar meteoro para an√°lisis">
                        <option value="">üîç Seleccionar meteoro...</option>
                    </select>
                    <div class="selector-actions" style="display:flex; gap:4px; margin-top:6px;">
                        <button id="refresh-meteor-selector" class="action-btn refresh-btn" title="Actualizar lista">
                            <span>üîÅ</span> Actualizar
                        </button>
                        <button id="plot-distance-btn" class="action-btn plot-btn" title="Generar gr√°fico de distancia" disabled>
                            <span>üìà</span> Gr√°fico
                        </button>
                    </div>
                </div>
            </div>

            <div id="meteor-info" class="meteor-info" style="display:none; margin-bottom:12px; padding:8px; background:rgba(56,169,255,0.1); border:1px solid var(--accent-color); border-radius:6px;">
                <div class="meteor-name" style="font-weight:600; color:var(--accent-color); margin-bottom:4px;"></div>
                <div class="meteor-details" style="font-size:0.85em; color:var(--text-color-secondary);"></div>
            </div>

            <div id="distance-plot-container" class="plot-container resizable-container" style="margin-top:12px; position:relative; min-width:400px; min-height:300px; max-width:800px; max-height:600px; resize:both; overflow:auto; border:2px solid var(--accent-color); border-radius:8px; background:rgba(0,0,0,0.1); display: none;">
                 <div class="plot-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding:8px; background:rgba(56,169,255,0.1); border-radius:6px 6px 0 0;">
                     <h4 style="margin:0; color:var(--accent-color); font-size:1em; font-weight:600;">üìà An√°lisis Temporal</h4>
                     <div style="display:flex; gap:8px; align-items:center;">
                         <span id="plot-size-indicator" style="font-size:0.8em; color:var(--text-color-secondary);">500√ó300</span>
                         <button id="close-plot" class="close-btn" title="Cerrar gr√°fico" style="background:none; border:none; color:var(--text-color-secondary); cursor:pointer; font-size:1.2em; padding:4px;">√ó</button>
                     </div>
                 </div>
                 
                 <div class="time-controls" style="margin-bottom:12px; padding:8px; background:rgba(0,0,0,0.2); border-radius:6px;">
                     <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                         <label style="font-size:0.9em; color:var(--text-color-secondary);">Escala temporal:</label>
                         <select id="time-scale-selector" style="padding:4px 8px; background:rgba(0,0,0,0.3); color:var(--text-color-primary); border:1px solid var(--ui-border-color); border-radius:4px; font-size:0.85em;">
                             <option value="52">1 a√±o (52 semanas)</option>
                             <option value="104">2 a√±os (104 semanas)</option>
                             <option value="260" selected>5 a√±os (260 semanas)</option>
                             <option value="520">10 a√±os (520 semanas)</option>
                             <option value="1040">20 a√±os (1040 semanas)</option>
                         </select>
                     </div>
                     <div style="display:flex; align-items:center; gap:8px;">
                         <label style="font-size:0.9em; color:var(--text-color-secondary);">Desplazamiento:</label>
                         <input type="range" id="time-offset-slider" min="0" max="100" value="0" step="1" style="flex:1; margin:0 8px;">
                         <span id="time-offset-display" style="font-size:0.85em; color:var(--accent-color); min-width:80px;">0 semanas</span>
                     </div>
                     <div style="display:flex; align-items:center; gap:8px; margin-top:6px;">
                         <button id="reset-time-view" style="padding:4px 8px; background:var(--accent-color); color:white; border:none; border-radius:4px; font-size:0.8em; cursor:pointer;">üîÑ Reset</button>
                         <button id="center-on-current-time" style="padding:4px 8px; background:var(--warning-color); color:white; border:none; border-radius:4px; font-size:0.8em; cursor:pointer;">üìç Centrar en tiempo actual</button>
                     </div>
                 </div>
                 
                 <div class="plot-wrapper" style="position:relative; background:rgba(0,0,0,0.3); border:1px solid var(--ui-border-color); border-radius:8px; padding:16px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                     <canvas id="distance-plot" width="500" height="300" style="width:100%; height:300px; border-radius:6px; background:rgba(0,0,0,0.1); border:1px solid rgba(255,255,255,0.1); display:block;"></canvas>
                     <div class="plot-legend" style="margin-top:12px; font-size:0.85em; color:var(--text-color-secondary); display:grid; grid-template-columns:1fr 1fr; gap:12px; padding:8px; background:rgba(0,0,0,0.2); border-radius:4px;">
                         <div style="display:flex; align-items:center; gap:6px;">
                             <div style="width:16px; height:3px; background:#38a9ff; border-radius:1px;"></div>
                             <span style="font-weight:500;">Distancia meteoro-Tierra</span>
                         </div>
                         <div style="display:flex; align-items:center; gap:6px;">
                             <div style="width:16px; height:3px; background:#ff4d6d; border-style:dashed; border-radius:1px;"></div>
                             <span style="font-weight:500;">Radio cr√≠tico</span>
                         </div>
                     </div>
                 </div>
            </div>
        </div>
        
        <hr style="border:none; border-top:1px solid var(--ui-border-color); opacity:.5;">
        <div id="prediction-panel" class="col">
            <h4 style="color:var(--accent-color); margin:0; font-size:1em;">üî≠ Calcular Posici√≥n Futura</h4>
            <div class="label">Selecciona fecha y hora:</div>
            <input type="datetime-local" id="prediction-date">
            
            <div class="label">Selecciona un asteroide (con datos):</div>
            <select id="prediction-asteroid-selector">
                <option value="">Cargando asteroides...</option>
            </select>

            <button id="prediction-calculate-btn">Calcular Posiciones</button>

            <div id="prediction-results">
                Selecciona una fecha y un asteroide para ver los resultados aqu√≠.
            </div>
        </div>
    </div>

    <div id="map-container" class="hidden">
        <div id="map-wrapper">
            <div id="map"></div>
            <div id="layer-toggle-panel" class="ui-panel">
                <h3>Visualizar Efecto</h3>
                <select id="layer-selector">
                    <option value="all">Todas las Capas</option>
                    <option value="crater" selected>Cr√°ter</option>
                    <option value="shockwave">Onda de Choque</option>
                    <option value="thermal">Radiaci√≥n T√©rmica</option>
                    <option value="tsunami">Tsunami</option>
                </select>
            </div>
            <div id="impact-results-panel" class="ui-panel hidden"></div>
            <button id="close-map-btn">&times;</button> 
            <div id="map-info" class="ui-panel">Selecciona un punto para el impacto</div>
        </div>
    </div>

<script type="importmap">
{ "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
} }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

// =========================================================================
// ====== SECCI√ìN DE SIMULACI√ìN DE IMPACTO (L√ìGICA DE ASTEROIDEFINAL) ======
// =========================================================================

const ASTEROID_DENSITY = 2700; const EARTH_DENSITY = 2700; const GRAVITY = 9.81; const EARTH_RADIUS = 6371000; const INITIAL_VELOCITY = 20000; const AERODYNAMIC_STRENGTH = 3e6; const STRENGTH_SCALING_ALPHA = 0.25; const NUM_FRAGMENTS = 2; const CLOUD_MASS_FRACTION = 0.5; const LUMINOUS_EFFICIENCY = 0.003; const THERMAL_Q_1ST_DEGREE = 0.13e6; const THERMAL_Q_2ND_DEGREE = 0.25e6; const THERMAL_Q_3RD_DEGREE = 0.42e6; const WATER_DENSITY = 1000; const FATALITY_RATES = { crater: 1.0, psi20: 0.98, psi5: 0.50, psi1: 0.05 }; const INJURY_RATES = { thermal3: 0.8, thermal2: 0.6, thermal1: 0.4 };

const COMPARISON_DATA = {
    energy: [ { name: 'Bomba de Hiroshima', value: 0.015 }, { name: 'Erupci√≥n Monte St. Helens', value: 24 }, { name: 'Bomba Tsar', value: 50 }, { name: 'Erupci√≥n del Krakatoa', value: 200 }, { name: 'Impacto de Chicxulub', value: 100000000 } ],
    earthquakeEvents: [ { mag: 6.7, name: "Northridge, EE.UU. 1994" }, { mag: 7.8, name: "San Francisco, EE.UU. 1906" }, { mag: 8.8, name: "Maule, Chile 2010" }, { mag: 9.1, name: "T≈çhoku, Jap√≥n 2011" }, { mag: 9.5, name: "Valdivia, Chile 1960" } ],
    tsunamiEvents: [ { height: 10, name: "O. √çndico 2004 (~30m)" }, { height: 50, name: "T≈çhoku, Jap√≥n 2011 (~40m)" }, { height: 100, name: "Bah√≠a Lituya 1958 (>500m)" } ]
};

let impactMap; let atmosphericSimResult = null; let currentImpactParams = null; let potentialImpactLatLng = null;
const mapLayers = { craterZone: null, psi20: null, psi5: null, psi1: null, thermal3: null, thermal2: null, thermal1: null, tsunami1: null, tsunami2: null, tsunami3: null };
const mainUiPanels = [ document.getElementById('top-left-hud'), document.getElementById('top-right-hud'), document.getElementById('bottom-center-hud'), document.getElementById('left-controls'), document.getElementById('nasa-panel') ];

function getAirDensity(altitude) { if (altitude > 100000) return 0; return 1.225 * Math.exp(-altitude / 8500); }
function runAtmosphericEntrySim(initialParams) { const initialMass = (4/3) * Math.PI * Math.pow(initialParams.radiusKm * 1000, 3) * ASTEROID_DENSITY; const initialEnergy = 0.5 * initialMass * INITIAL_VELOCITY**2; let fragments = [{ m: initialMass, v: INITIAL_VELOCITY, theta: initialParams.angle * (Math.PI / 180), h: 100000, strength: AERODYNAMIC_STRENGTH, isCloud: false }]; let fragmentsThatHit = []; let maxEnergyDepositionAltitude = 0; let peakEnergyDeposited = 0; const dt = 0.05; while (fragments.length > 0) { const newFragments = []; const fragmentsToRemove = []; for (const frag of fragments) { if (frag.h <= 0 || frag.m < 1) { if (frag.h <= 0 && frag.m >= 1) fragmentsThatHit.push(frag); fragmentsToRemove.push(frag); continue; } const rho_air = getAirDensity(frag.h); const dynamic_pressure = rho_air * frag.v * frag.v; const kineticEnergyBefore = 0.5 * frag.m * frag.v * frag.v; if (!frag.isCloud && dynamic_pressure > frag.strength) { fragmentsToRemove.push(frag); const cloudMass = frag.m * CLOUD_MASS_FRACTION; if (cloudMass > 1) newFragments.push({ ...frag, m: cloudMass, isCloud: true }); const childMass = (frag.m - cloudMass) / NUM_FRAGMENTS; if (childMass > 1) { const childStrength = frag.strength * Math.pow(frag.m / childMass, STRENGTH_SCALING_ALPHA); for (let i = 0; i < NUM_FRAGMENTS; i++) { newFragments.push({ ...frag, m: childMass, strength: childStrength, isCloud: false }); } } continue; } const ABLATION_COEFFICIENT = 1e-7; const DRAG_COEFFICIENT = 1.0; const currentRadius = Math.pow((3 * frag.m) / (4 * Math.PI * ASTEROID_DENSITY), 1/3); const A = Math.PI * Math.pow(currentRadius, 2); const dm_dt = -0.5 * rho_air * Math.pow(frag.v, 3) * A * ABLATION_COEFFICIENT; const dv_dt = -0.5 * rho_air * Math.pow(frag.v, 2) * A * DRAG_COEFFICIENT / frag.m - GRAVITY * Math.sin(frag.theta); const dtheta_dt = (frag.v / (EARTH_RADIUS + frag.h) - GRAVITY / frag.v) * Math.cos(frag.theta); const dh_dt = -frag.v * Math.sin(frag.theta); frag.m += dm_dt * dt; frag.v += dv_dt * dt; frag.theta += dtheta_dt * dt; frag.h += dh_dt * dt; const kineticEnergyAfter = 0.5 * frag.m * frag.v * frag.v; const energyDeposited = kineticEnergyBefore - kineticEnergyAfter; if (energyDeposited > peakEnergyDeposited) { peakEnergyDeposited = energyDeposited; maxEnergyDepositionAltitude = frag.h; } } fragments = fragments.filter(f => !fragmentsToRemove.includes(f)).concat(newFragments); } const burstAltitude = fragmentsThatHit.length === 0 ? maxEnergyDepositionAltitude : 0; let impactVelocity = 0; if (fragmentsThatHit.length > 0) { fragmentsThatHit.sort((a, b) => b.m - a.m); impactVelocity = fragmentsThatHit[0].v; } return { impact: fragmentsThatHit.length > 0, totalEnergy: initialEnergy, burstAltitude, impactVelocity }; }
function calculateTsunamiIsolines(impactEnergy, impactAngle) { const H = 4000; const E = impactEnergy; const T = impactAngle * (Math.PI / 180); const L_cubed = (12 * E) / (Math.PI * ASTEROID_DENSITY * Math.pow(INITIAL_VELOCITY, 2)); const L = Math.pow(L_cubed, 1/3); const Dtc = 1.365 * Math.pow(ASTEROID_DENSITY / WATER_DENSITY, 1/3) * Math.pow(L, 0.78) * Math.pow(INITIAL_VELOCITY, 0.44) * Math.pow(GRAVITY, -0.22) * Math.pow(Math.sin(T), 1/3); const Amax_rw_theoretical = Dtc / 14.1; const Amax_rw = Math.min(Amax_rw_theoretical, H); const Rrw = (3 * Dtc) / 4; let Amax_cw = 0, Rcw = 0, q = 0; if (H > 2 * L) { const dtc = Dtc / 2.828; Amax_cw = 0.06 * Math.min(dtc, H); Rcw = (5 * Dtc) / 2; const L_over_H = L / H; q = (L_over_H < 0.5) ? 3 * Math.exp(-0.8 * L_over_H) : 3 * Math.exp(-0.8 * 0.5); } const targetAmplitudes = [100, 50, 10]; const radii = {}; targetAmplitudes.forEach(A_target => { let r_rw = 0, r_cw = 0; if (A_target > 0 && A_target < Amax_rw) { r_rw = Amax_rw * Rrw / A_target; } if (A_target > 0 && A_target < Amax_cw && q > 0) { r_cw = Rcw / Math.pow(A_target / Amax_cw, 1/q); } radii[A_target] = Math.max(r_rw, r_cw); }); return radii; }
function getPopulationDensity(latlng) { if (latlng.lat > 60 || latlng.lat < -60) return 1; const lat = Math.abs(latlng.lat); if (lat < 20) return 60; if (lat < 55) return 150; return 20; }
function estimateCasualties(radii, populationDensity) { const getAreaKm2 = (radiusM) => Math.PI * Math.pow(radiusM / 1000, 2); const areaCrater = getAreaKm2(radii.crater); const areaPsi20 = getAreaKm2(radii.psi20); const areaPsi5 = getAreaKm2(radii.psi5); const areaPsi1 = getAreaKm2(radii.psi1); const areaThermal3 = getAreaKm2(radii.thermal3); const areaThermal2 = getAreaKm2(radii.thermal2); const areaThermal1 = getAreaKm2(radii.thermal1); const fatalities = Math.round( (areaCrater * populationDensity * FATALITY_RATES.crater) + ((areaPsi20 - areaCrater) * populationDensity * FATALITY_RATES.psi20) + ((areaPsi5 - areaPsi20) * populationDensity * FATALITY_RATES.psi5) + ((areaPsi1 - areaPsi5) * populationDensity * FATALITY_RATES.psi1) ); const thirdDegreeBurns = Math.round(areaThermal3 * populationDensity * INJURY_RATES.thermal3); const secondDegreeBurns = Math.round((areaThermal2 - areaThermal3) * populationDensity * INJURY_RATES.thermal2); const firstDegreeBurns = Math.round((areaThermal1 - areaThermal2) * populationDensity * INJURY_RATES.thermal1); return { fatalities: fatalities > 0 ? fatalities : 0, thirdDegreeBurns: thirdDegreeBurns > 0 ? thirdDegreeBurns : 0, secondDegreeBurns: secondDegreeBurns > 0 ? secondDegreeBurns : 0, firstDegreeBurns: firstDegreeBurns > 0 ? firstDegreeBurns : 0, }; }
function calculateAirblastRadius(energyMegatons, overpressurePsi) { if (energyMegatons <= 0) return 0; const W_pow_1_3 = Math.pow(energyMegatons, 1/3); let radiusKm; switch(overpressurePsi) { case 20: radiusKm = 1.6 * W_pow_1_3; break; case 5: radiusKm = 4.5 * W_pow_1_3; break; case 1: default: radiusKm = 12 * W_pow_1_3; break; } return radiusKm * 1000; }
function calculateThermalRadius(energy, thermal_q, burst_altitude) { if (energy <= 0) return 0; const slant_range_sq = (LUMINOUS_EFFICIENCY * energy) / (2 * Math.PI * thermal_q); if (slant_range_sq < burst_altitude**2) return 0; return Math.sqrt(slant_range_sq - burst_altitude**2); }
function clearMapLayers() { for (const key in mapLayers) { if (mapLayers[key] && impactMap.hasLayer(mapLayers[key])) { impactMap.removeLayer(mapLayers[key]); } mapLayers[key] = null; } }
function animateWave(circle, finalRadius, duration) { if (!circle || finalRadius <= 0) return; let start = null; function step(timestamp) { if (!start) start = timestamp; const progress = timestamp - start; const currentRadius = Math.min((progress / duration) * finalRadius, finalRadius); circle.setRadius(currentRadius); if (progress < duration) { window.requestAnimationFrame(step); } } window.requestAnimationFrame(step); }
function updateResultsPanelVisibility() { const selectedValue = document.getElementById('layer-selector').value; const sections = document.querySelectorAll('#impact-results-panel .result-section'); const visibleCategories = { all: ['summary', 'shockwave', 'thermal', 'casualties', 'comparison', 'tsunami'], crater: ['summary', 'casualties', 'comparison'], shockwave: ['shockwave'], thermal: ['thermal'], tsunami: ['tsunami', 'comparison'] }; const toShow = visibleCategories[selectedValue] || []; sections.forEach(section => { const category = section.dataset.category; if (selectedValue === 'all' || toShow.includes(category)) { section.style.display = 'block'; } else { section.style.display = 'none'; } }); }
function updateMapLayersVisibility() { if (!impactMap) return; const layerCategories = { crater: ['craterZone'], shockwave: ['psi1', 'psi5', 'psi20'], thermal: ['thermal1', 'thermal2', 'thermal3'], tsunami: ['tsunami1', 'tsunami2', 'tsunami3'] }; const selectedCategory = document.getElementById('layer-selector').value; let layersToShow = []; if (selectedCategory === 'all') { layersToShow = Object.values(layerCategories).flat(); } else { layersToShow = layerCategories[selectedCategory] || []; } for (const key in mapLayers) { const layer = mapLayers[key]; if (layer) { if (layersToShow.includes(key)) { if (!impactMap.hasLayer(layer)) impactMap.addLayer(layer); } else { if (impactMap.hasLayer(layer)) impactMap.removeLayer(layer); } } } }
async function checkIfOnWater(lat, lng) { try { const response = await fetch(`https://is-on-water.balbona.me/api/v1/get/${lat}/${lng}`); if (!response.ok) { throw new Error(`Error en la API: ${response.statusText}`); } return await response.json(); } catch (error) { console.error("Error al consultar la API Is On Water:", error); return null; } }
async function generateComparisonContent(energyMt, richterMagnitude) { let html = `<div class="result-section" data-category="comparison"><hr><h3>Comparaci√≥n de Efectos</h3>`; let energyEvent = COMPARISON_DATA.energy[0]; for (const event of COMPARISON_DATA.energy) { if (energyMt <= event.value) { break; } energyEvent = event; } html += `<div class="data-row"><span class="data-label">‚ö° Energ√≠a:</span><span class="data-value">${energyEvent.name}</span></div>`; if (richterMagnitude && richterMagnitude > 6.0) { let closestQuake = COMPARISON_DATA.earthquakeEvents[0]; let smallestDiff = Infinity; for (const event of COMPARISON_DATA.earthquakeEvents) { const diff = Math.abs(richterMagnitude - event.mag); if (diff < smallestDiff) { smallestDiff = diff; closestQuake = event; } } html += `<div class="data-row"><span class="data-label">üåé Sismo:</span><span class="data-value">${closestQuake.name} (M${closestQuake.mag})</span></div>`; } html += `</div>`; return html; }
async function onMapClick(e) { if (!atmosphericSimResult || !currentImpactParams) return; clearMapLayers(); const centerLatLng = e.latlng; const mapInfoDiv = document.getElementById('map-info'); const resultsPanel = document.getElementById('impact-results-panel'); resultsPanel.classList.add('hidden'); mapInfoDiv.innerText = 'Calculando efectos del impacto...'; const locationData = await checkIfOnWater(centerLatLng.lat, centerLatLng.lng); if (!locationData) { mapInfoDiv.innerText = 'Error al determinar la ubicaci√≥n.'; return; } mapInfoDiv.innerText = `Impacto en: Lat ${centerLatLng.lat.toFixed(4)}, Lon ${centerLatLng.lng.toFixed(4)}`; let resultsHTML = ''; if (atmosphericSimResult.impact || atmosphericSimResult.burstAltitude > 0) { const totalEnergyJoules = atmosphericSimResult.totalEnergy; const totalEnergyMegatons = totalEnergyJoules / 4.184e15; const burstAltitude = atmosphericSimResult.burstAltitude; if (locationData.isWater) { const tsunamiRadii = calculateTsunamiIsolines(totalEnergyJoules, currentImpactParams.angle); if (tsunamiRadii[10] > 0) { mapLayers.tsunami3 = L.circle(centerLatLng, { radius: 0, color: '#00008B', fillColor: '#000080', fillOpacity: 0.5, weight: 2 }).addTo(impactMap).bindTooltip("Altura de ola: 100 metros"); mapLayers.tsunami2 = L.circle(centerLatLng, { radius: 0, color: '#4169E1', fillColor: '#0000CD', fillOpacity: 0.4, weight: 2 }).addTo(impactMap).bindTooltip("Altura de ola: 50 metros"); mapLayers.tsunami1 = L.circle(centerLatLng, { radius: 0, color: '#6495ED', fillColor: '#1E90FF', fillOpacity: 0.4, weight: 2 }).addTo(impactMap).bindTooltip("Altura de ola: 10 metros"); animateWave(mapLayers.tsunami3, tsunamiRadii[100], 2000); setTimeout(() => animateWave(mapLayers.tsunami2, tsunamiRadii[50], 2300), 400); setTimeout(() => animateWave(mapLayers.tsunami1, tsunamiRadii[10], 2600), 800); } resultsHTML = `<div class="result-section" data-category="summary"><h3>Resumen del Evento</h3><div class="data-row"><span class="data-label">Tipo:</span> <span class="data-value" style="color: #3b82f6;">Agua</span></div><div class="data-row"><span class="data-label">Energ√≠a:</span> <span class="data-value">${totalEnergyMegatons.toFixed(2)} Mt</span></div><div class="data-row"><span class="data-label">Altitud explosi√≥n:</span> <span class="data-value">${(burstAltitude / 1000).toFixed(1)} km</span></div></div><div class="result-section" data-category="tsunami"><hr><h3>Riesgo de Tsunami</h3><div class="data-row"><span class="data-label">Distancia ola 10m:</span> <span class="data-value">${(tsunamiRadii[10] / 1000).toFixed(1)} km</span></div><div class="data-row"><span class="data-label">Distancia ola 50m:</span> <span class="data-value">${(tsunamiRadii[50] / 1000).toFixed(1)} km</span></div><div class="data-row"><span class="data-label">Distancia ola 100m:</span> <span class="data-value">${(tsunamiRadii[100] / 1000).toFixed(1)} km</span></div></div>`; let tsunamiComparisonHTML = `<div class="result-section" data-category="comparison"><hr><h3>Comparaci√≥n de Efectos</h3>`; let comparisonEvent = null; if (tsunamiRadii[100] > 0) { comparisonEvent = COMPARISON_DATA.tsunamiEvents.find(e => e.height === 100); } else if (tsunamiRadii[50] > 0) { comparisonEvent = COMPARISON_DATA.tsunamiEvents.find(e => e.height === 50); } else if (tsunamiRadii[10] > 0) { comparisonEvent = COMPARISON_DATA.tsunamiEvents.find(e => e.height === 10); } if(comparisonEvent){ tsunamiComparisonHTML += `<div class="data-row"><span class="data-label">üåä Tsunami:</span><span class="data-value">${comparisonEvent.name}</span></div>`; } tsunamiComparisonHTML += `</div>`; resultsHTML += tsunamiComparisonHTML; } else { let craterDiameterKm = 0; let craterRadiusM = 0; if (burstAltitude === 0 && totalEnergyMegatons > 0.01) { const asteroidDiameterM = currentImpactParams.radiusKm * 2 * 1000; const impactVelocity = atmosphericSimResult.impactVelocity; const impactAngleDegrees = currentImpactParams.angle; craterDiameterKm = 1.161 * Math.pow(ASTEROID_DENSITY / EARTH_DENSITY, 1/3) * Math.pow(asteroidDiameterM, 0.78) * Math.pow(impactVelocity, 0.44) * Math.pow(GRAVITY, -0.22) * Math.pow(Math.sin(impactAngleDegrees * Math.PI / 180), 1/3) / 1000; craterRadiusM = (craterDiameterKm / 2) * 1000; mapLayers.craterZone = L.circle(centerLatLng, { radius: 0, color: '#dc2626', fillColor: '#3b1c00', fillOpacity: 0.7, weight: 3, dashArray: '10, 10' }).addTo(impactMap); animateWave(mapLayers.craterZone, craterRadiusM, 1500); } const blastRadius20psi = calculateAirblastRadius(totalEnergyMegatons, 20); const blastRadius5psi = calculateAirblastRadius(totalEnergyMegatons, 5); const blastRadius1psi = calculateAirblastRadius(totalEnergyMegatons, 1); mapLayers.psi20 = L.circle(centerLatLng, { radius: 0, color: '#4d4d4d', fillColor: '#4d4d4d', fillOpacity: 0.5, weight: 2 }).addTo(impactMap).bindTooltip("20 PSI: Destrucci√≥n total"); mapLayers.psi5 = L.circle(centerLatLng, { radius: 0, color: '#808080', fillColor: '#808080', fillOpacity: 0.4, weight: 2 }).addTo(impactMap).bindTooltip("5 PSI: Colapso de casas"); mapLayers.psi1 = L.circle(centerLatLng, { radius: 0, color: '#bfbfbf', fillColor: '#bfbfbf', fillOpacity: 0.3, weight: 2, dashArray: '5, 5' }).addTo(impactMap).bindTooltip("1 PSI: Rotura de ventanas"); animateWave(mapLayers.psi20, blastRadius20psi, 1800); setTimeout(() => animateWave(mapLayers.psi5, blastRadius5psi, 2100), 300); setTimeout(() => animateWave(mapLayers.psi1, blastRadius1psi, 2400), 600); const thermalRadius1 = calculateThermalRadius(totalEnergyJoules, THERMAL_Q_1ST_DEGREE, burstAltitude); const thermalRadius2 = calculateThermalRadius(totalEnergyJoules, THERMAL_Q_2ND_DEGREE, burstAltitude); const thermalRadius3 = calculateThermalRadius(totalEnergyJoules, THERMAL_Q_3RD_DEGREE, burstAltitude); mapLayers.thermal3 = L.circle(centerLatLng, { radius: thermalRadius3, color: '#f87171', fillOpacity: 0.5, weight: 2 }).bindTooltip("Quemaduras 3er Grado"); mapLayers.thermal2 = L.circle(centerLatLng, { radius: thermalRadius2, color: '#fb923c', fillOpacity: 0.4, weight: 2 }).bindTooltip("Quemaduras 2do Grado"); mapLayers.thermal1 = L.circle(centerLatLng, { radius: thermalRadius1, color: '#fde047', fillOpacity: 0.4, weight: 2, dashArray: '5, 5' }).bindTooltip("Quemaduras 1er Grado"); const populationDensity = getPopulationDensity(centerLatLng); const casualties = estimateCasualties({ crater: craterRadiusM, psi20: blastRadius20psi, psi5: blastRadius5psi, psi1: blastRadius1psi, thermal3: thermalRadius3, thermal2: thermalRadius2, thermal1: thermalRadius1 }, populationDensity); const richterMagnitude = 0.67 * Math.log10(totalEnergyJoules) - 5.87; resultsHTML = `<div class="result-section" data-category="summary"><h3>Resumen del Evento</h3><div class="data-row"><span class="data-label">Tipo:</span> <span class="data-value" style="color: #22c55e;">Tierra</span></div><div class="data-row"><span class="data-label">Energ√≠a:</span> <span class="data-value">${totalEnergyMegatons.toFixed(2)} Mt</span></div><div class="data-row"><span class="data-label">Di√°metro Cr√°ter:</span> <span class="data-value">${craterDiameterKm.toFixed(2)} km</span></div><div class="data-row"><span class="data-label">Sismo (Richter):</span> <span class="data-value">${richterMagnitude > 0 ? richterMagnitude.toFixed(1) : 'N/A'}</span></div></div><div class="result-section" data-category="shockwave"><hr><h3>Onda de Choque (Sobrepresi√≥n)</h3><div class="data-row"><span class="data-label" style="color:#bfbfbf;">20 PSI (Destrucci√≥n total):</span> <span class="data-value">${(blastRadius20psi / 1000).toFixed(1)} km</span></div><div class="data-row"><span class="data-label" style="color:#808080;">5 PSI (Colapso casas):</span> <span class="data-value">${(blastRadius5psi / 1000).toFixed(1)} km</span></div><div class="data-row"><span class="data-label" style="color:#4d4d4d;">1 PSI (Rotura ventanas):</span> <span class="data-value">${(blastRadius1psi / 1000).toFixed(1)} km</span></div></div><div class="result-section" data-category="thermal"><hr><h3>Radiaci√≥n T√©rmica</h3><div class="data-row"><span class="data-label">Quemaduras 3¬∞:</span> <span class="data-value">${(thermalRadius3 / 1000).toFixed(1)} km</span></div><div class="data-row"><span class="data-label">Quemaduras 2¬∞:</span> <span class="data-value">${(thermalRadius2 / 1000).toFixed(1)} km</span></div><div class="data-row"><span class="data-label">Quemaduras 1¬∞:</span> <span class="data-value">${(thermalRadius1 / 1000).toFixed(1)} km</span></div></div><div class="result-section" data-category="casualties"><hr><h3>Estimaci√≥n de V√≠ctimas</h3><div class="data-row"><span class="data-label">Fatalidades:</span> <span class="data-value">${casualties.fatalities.toLocaleString()}</span></div><div class="data-row"><span class="data-label">Heridos graves:</span> <span class="data-value">${casualties.thirdDegreeBurns.toLocaleString()}</span></div><div class="data-row"><span class="data-label">Heridos leves:</span> <span class="data-value">${(casualties.secondDegreeBurns + casualties.firstDegreeBurns).toLocaleString()}</span></div></div>`; const comparisonHTML = await generateComparisonContent(totalEnergyMegatons, richterMagnitude); resultsHTML += comparisonHTML; } } else { resultsHTML = `<h3>Sin Impacto</h3><p>El asteroide se desintegr√≥ por completo en la atm√≥sfera.</p>`; } resultsPanel.innerHTML = resultsHTML; resultsPanel.classList.remove('hidden'); updateMapLayersVisibility(); updateResultsPanelVisibility(); }

function launchImpactSimulator(asteroid) {
    let radiusKm = 0.1; // Default
    if (asteroid.kind === 'sim') {
        const diameterMeters = Number(document.getElementById('diameter')?.value || 200);
        radiusKm = diameterMeters / 2000;
    } else if (asteroid.neoDetails) {
        const diameterMeters = asteroid.neoDetails.estimated_diameter.meters.estimated_diameter_max;
        radiusKm = diameterMeters / 2000;
    }

    currentImpactParams = {
        radiusKm: radiusKm,
        angle: 45, // √Ångulo de impacto asumido
    };
    
    atmosphericSimResult = runAtmosphericEntrySim(currentImpactParams);
    
    const mapContainer = document.getElementById('map-container');
    mainUiPanels.forEach(panel => panel.style.display = 'none');
    mapContainer.classList.remove('hidden');

    if (!impactMap) {
        impactMap = L.map('map').setView([20, 0], 2);
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        }).addTo(impactMap);
        impactMap.on('click', onMapClick);
        
        document.getElementById('close-map-btn').addEventListener('click', () => {
            mapContainer.classList.add('hidden');
            document.getElementById('impact-results-panel').classList.add('hidden');
            mainUiPanels.forEach(panel => panel.style.display = ''); // Re-show main UI
        });

        document.getElementById('layer-selector').addEventListener('change', () => {
            updateMapLayersVisibility();
            updateResultsPanelVisibility();
        });
    }
    
    setTimeout(() => impactMap.invalidateSize(), 100);

    // Si hay un punto de impacto calculado, ejecutar la simulaci√≥n ah√≠ autom√°ticamente
    if (potentialImpactLatLng) {
        impactMap.setView(potentialImpactLatLng, 5); // Centrar el mapa en el punto
        onMapClick({ latlng: potentialImpactLatLng });
    }
}


// =========================================================================
// ====== C√ìDIGO PRINCIPAL DE MONTECARLO_ORBITAL (CON MODIFICACIONES) ======
// =========================================================================

/* =================== RENDER =================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0px';
labelRenderer.domElement.style.pointerEvents = 'none';
document.body.appendChild(labelRenderer.domElement);

const textureLoader = new THREE.TextureLoader();
textureLoader.setCrossOrigin('anonymous');
function tuneTexture(tex){
    if(!tex) return;
    tex.anisotropy = Math.min(16, renderer.capabilities.getMaxAnisotropy?.() || 8);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.generateMipmaps = true;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
}

/* =================== ESTADO =================== */
let simulationDate = new Date();
let isPaused = false;
let isLive = true;
let timeScale = 86400;
const timeSlider = document.getElementById('time-speed');
const timeSpeedLabel = document.getElementById('time-speed-label');
let asteroidVisualMode = 'single';
const asteroids = [];
let lastFetchedNeoIds = [];
const neoCache = new Map();
const LS_key = 'neo_cache_v1'; const TTL_MS = 6*3600*1000;
function loadLSCache(){ try{ const raw=localStorage.getItem(LS_key); if(!raw) return; const obj=JSON.parse(raw); const now=Date.now(); for(const [id,pack] of Object.entries(obj)){ if(now-pack.ts<TTL_MS) neoCache.set(id,pack); } }catch{} }
function saveLSCache(){ try{ const obj={}; for(const [id,pack] of neoCache.entries()) obj[id]=pack; localStorage.setItem(LS_key, JSON.stringify(obj)); }catch{} }
loadLSCache();
const filterOnlyPHA = document.getElementById('filter-only-pha');
const filterHideNonPHA = document.getElementById('filter-hide-nonpha');
filterOnlyPHA.addEventListener('change', ()=>{ if(filterOnlyPHA.checked) filterHideNonPHA.checked=true; applyFilters(); });
filterHideNonPHA.addEventListener('change', ()=>{ if(!filterHideNonPHA.checked) filterOnlyPHA.checked=false; applyFilters(); });
const visibility = { sun:true, planets:true, earth:true, moon:true, planetOrbits:true, earthOrbit:true, astOrbits:true, astMarkers:true, labels:true };
const mousePos = new THREE.Vector2();
window.addEventListener('mousemove', (event) => { mousePos.x = event.clientX; mousePos.y = event.clientY; });
let orbitObjects = [];
let hoveredOrbit = null;
let objetosVisualizacion = [];

/* ======= ESCENA Y CONTROLES ======= */
const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 20000);
camera.position.set(0, 220, 360);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 1;
controls.maxDistance = 12000;
controls.enablePan = false;
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);
const sunLight = new THREE.PointLight(0xFFF4D6, 25, 20000);
sunLight.position.set(0,0,0);
scene.add(sunLight);
const starsTex = textureLoader.load('8k_stars_milky_way.jpg', tuneTexture);
const skybox = new THREE.Mesh(new THREE.SphereGeometry(16000, 64, 64), new THREE.MeshBasicMaterial({ map: starsTex, side: THREE.BackSide }));
scene.add(skybox);
const raycaster = new THREE.Raycaster();
raycaster.params.Line.threshold = 3; 
const mouse = new THREE.Vector2();
let clickableObjects = [];

renderer.domElement.addEventListener('pointerdown', (e)=>{
    if (e.target.closest('#map-container')) return; // Ignorar clicks en el mapa
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX-rect.left)/rect.width)*2-1;
    mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;
    raycaster.setFromCamera(mouse, camera);

    const hits = raycaster.intersectObjects([...clickableObjects, ...orbitObjects], true);
    if (hits.length > 0) {
        let hitObject = hits[0].object;
        if (hitObject.userData.celestialBody) {
            selectObject(hitObject.userData.celestialBody);
        } else {
            while (hitObject && !hitObject.userData?.id && hitObject.parent) {
                hitObject = hitObject.parent;
            }
            if (hitObject?.userData?.id) {
                selectObject(hitObject);
            }
        }
    }
});

/* ======= CUERPOS CELESTES ======= */
const sunTex = textureLoader.load('8k_sun.jpg', tuneTexture);
const sun = new THREE.Mesh(new THREE.SphereGeometry(7,64,64), new THREE.MeshBasicMaterial({ map: sunTex }));
sun.userData = { id:'sol', name:'Sol', info:`<p>Estrella G2V.</p>`, symbol:'‚òâ', texture: '8k_sun.jpg', isAsteroid: false };
scene.add(sun);

const planets = [];
const planetData = [
    { name: 'Mercurio', symbol: '‚òø', radius: 0.38, distance: 0.39, period: 87.97, color: 0x8c7853, info: 'Planeta m√°s cercano al Sol' },
    { name: 'Venus', symbol: '‚ôÄ', radius: 0.95, distance: 0.72, period: 224.7, color: 0xffc649, info: 'Planeta m√°s caliente del sistema solar' },
    { name: 'Marte', symbol: '‚ôÇ', radius: 0.53, distance: 1.52, period: 686.98, color: 0xc1440e, info: 'El planeta rojo' },
    { name: 'J√∫piter', symbol: '‚ôÉ', radius: 11.2, distance: 5.20, period: 4332.59, color: 0xd8ca9d, info: 'El gigante gaseoso' },
    { name: 'Saturno', symbol: '‚ôÑ', radius: 9.45, distance: 9.58, period: 10759.22, color: 0xfad5a5, info: 'Planeta con anillos' },
    { name: 'Urano', symbol: '‚ôÖ', radius: 4.01, distance: 19.22, period: 30688.5, color: 0x4fd0e3, info: 'Planeta inclinado' },
    { name: 'Neptuno', symbol: '‚ôÜ', radius: 3.88, distance: 30.05, period: 60182, color: 0x4b70dd, info: 'El planeta azul' }
];

planetData.forEach((data, index) => {
    const planetGroup = new THREE.Group();
    const planet = new THREE.Mesh(
        new THREE.SphereGeometry(data.radius * 0.5, 32, 32),
        new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.8, metalness: 0.1 })
    );
    
    planet.userData = {
        id: `planeta_${data.name.toLowerCase()}`,
        name: data.name,
            info: `<p>${data.info}</p><p>Distancia al Sol: <span class="valor">${data.distance} AU</span></p><p>Per√≠odo orbital: <span class="valor">${data.period.toFixed(1)} d√≠as</span></p>`,
            symbol: data.symbol,
            isAsteroid: false,
            planetData: data
        };
    
    planetGroup.add(planet);
    scene.add(planetGroup);
    clickableObjects.push(planet);
    
    const orbitRadius = data.distance * 200;
    const orbit = createOrbitLine(orbitRadius, orbitRadius, data.color, 0);
    orbit.userData.celestialBody = planet;
    orbit.userData.originalColor = orbit.material.color.clone();
    orbitObjects.push(orbit);
    scene.add(orbit);
    
    const label = createLabel(data.name);
    planet.add(label);
    
    planets.push({
        group: planetGroup,
        planet: planet,
        orbit: orbit,
        label: label,
        data: data
    });
});

const earthGroup = new THREE.Group(); 
scene.add(earthGroup);
const earthDayTex = textureLoader.load('8k_earth_daymap.jpg', tuneTexture);
const earthNightTex = textureLoader.load('8k_earth_nightmap.jpg', tuneTexture);
earthDayTex.offset.x = 0.5; earthNightTex.offset.x = 0.5;
earthDayTex.wrapS = THREE.RepeatWrapping; earthNightTex.wrapS = THREE.RepeatWrapping;
const earthBlendMat = new THREE.ShaderMaterial({
    uniforms:{ dayTex:{value:earthDayTex}, nightTex:{value:earthNightTex}, lightPos:{value:new THREE.Vector3(0,0,0)}, softness:{value:0.22}, dayBoost:{value:0.8} },
    vertexShader:`varying vec3 vWorldPos; varying vec3 vWorldNormal; varying vec2 vUv; void main(){ vUv=uv; vec4 wp=modelMatrix*vec4(position,1.0); vWorldPos=wp.xyz; vWorldNormal=normalize(mat3(modelMatrix)*normal); gl_Position=projectionMatrix*viewMatrix*wp; }`,
    fragmentShader:`uniform sampler2D dayTex; uniform sampler2D nightTex; uniform vec3 lightPos; uniform float softness; uniform float dayBoost; varying vec3 vWorldPos; varying vec3 vWorldNormal; varying vec2 vUv; void main(){ vec3 N = normalize(vWorldNormal); vec3 L = normalize(lightPos - vWorldPos); float ndotl = max(dot(N, L), 0.0); float t = smoothstep(0.0, softness, ndotl); vec3 day = texture2D(dayTex, vUv).rgb; vec3 night = texture2D(nightTex, vUv).rgb; vec3 lit = clamp(day + day*(dayBoost*ndotl), 0.0, 1.0); vec3 color = mix(night, lit, t); gl_FragColor = vec4(color, 1.0); }`
});
const earth = new THREE.Mesh(new THREE.SphereGeometry(2,64,64), earthBlendMat);
earth.userData = { id:'tierra', name:'Tierra', info:`<p>Inclinaci√≥n axial: <span class="valor">23.44¬∞</span></p>`, symbol:'‚ôÅ', texture: '8k_earth_daymap.jpg', isAsteroid: false };
const cloudTex = textureLoader.load('8k_earth_clouds.jpg', tuneTexture);
const cloudMesh = new THREE.Mesh(new THREE.SphereGeometry(2.02,64,64), new THREE.MeshStandardMaterial({ map:cloudTex, transparent:true, opacity:0.26, alphaTest:0.1 }));
earth.add(cloudMesh);
earthGroup.add(earth);
const moonTex = textureLoader.load('8k_moon.jpg', tuneTexture);
const moon = new THREE.Mesh(new THREE.SphereGeometry(0.5,64,64), new THREE.MeshStandardMaterial({ map:moonTex, roughness:0.9, emissive: 0xffffff, emissiveIntensity: 0.05 }));
moon.userData = { id:'luna', name:'Luna', info:`<p>Periodo sideral: <span class="valor">27.321661 d√≠as</span></p>`, symbol:'‚òæ', texture: '8k_moon.jpg', isAsteroid: false };
earthGroup.add(moon);
const asteroidTex = textureLoader.load('Asteroide4k.jpg', tuneTexture);
clickableObjects.push(sun, earth, moon);

/* ======= ETIQUETAS 3D Y √ìRBITAS ======= */
function createLabel(name) {
    const labelDiv = document.createElement('div');
    labelDiv.className = 'label3d';
    labelDiv.textContent = name;
    const label = new CSS2DObject(labelDiv);
    label.position.set(0, 0, 0);
    return label;
}
sun.label = createLabel('Sol'); sun.add(sun.label);
earth.label = createLabel('Tierra'); earth.add(earth.label);
moon.label = createLabel('Luna'); moon.add(moon.label);
let hoveredObject = null;
function updateLabels() {
    if (!visibility.labels) { document.querySelectorAll('.label3d.visible').forEach(l => l.classList.remove('visible')); return; }
    const raycasterMouse = new THREE.Vector2((mousePos.x / window.innerWidth) * 2 - 1, -(mousePos.y / window.innerHeight) * 2 + 1);
    raycaster.setFromCamera(raycasterMouse, camera);
    const intersects = raycaster.intersectObjects(clickableObjects, true);
    let currentlyHovered = null;
    if (intersects.length > 0) {
        let hit = intersects[0].object;
        while(hit && !hit.userData?.id && hit.parent) hit = hit.parent;
        if (hit?.userData?.id) { currentlyHovered = hit; }
    }
    hoveredObject = currentlyHovered;
    const planetObjects = planets.map(p => p.planet);
    const labeledObjects = [sun, ...planetObjects, earth, moon, ...asteroids.map(a => a.marker).filter(m => m)];
    const worldVector = new THREE.Vector3();
    labeledObjects.forEach(obj => {
        if (!obj || !obj.label) return;
        const baseOffset = obj.geometry.boundingSphere ? obj.geometry.boundingSphere.radius * 1.5 : 1;
        obj.label.position.set(0, baseOffset, 0);
        let isVisibleByFilter = true;
        if (obj.userData && (obj.userData.id.startsWith('neo_') || obj.userData.id.startsWith('sim_'))) {
            const asteroidRecord = asteroids.find(a => a.marker === obj);
            if (asteroidRecord) { isVisibleByFilter = isAsteroidVisibleByFilter(asteroidRecord); }
        }
        obj.getWorldPosition(worldVector);
        worldVector.project(camera);
        const isBehindCamera = worldVector.z > 1;
        const showLabel = (obj === hoveredObject) && isVisibleByFilter && obj.visible && !isBehindCamera;
        obj.label.element.classList.toggle('visible', showLabel);
    });
}
const earthOrbitRadius = 200;
const moonOrbitRadius  = 12;
function createOrbitLine(radiusX, radiusZ, color, inclinationDegrees=0){
    const pts = []; const inc = THREE.MathUtils.degToRad(inclinationDegrees);
    for(let i=0;i<=360;i++){ const a = THREE.MathUtils.degToRad(i), x = radiusX*Math.cos(a), zf = radiusZ*Math.sin(a), y = zf*Math.sin(inc), z = zf*Math.cos(inc); pts.push(new THREE.Vector3(x,y,z)); }
    const geometry = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.4 });
    return new THREE.Line(geometry, mat);
}
const earthOrbitLine = createOrbitLine(earthOrbitRadius, earthOrbitRadius, 0x38a9ff, 0);
earthOrbitLine.userData.celestialBody = earth;
earthOrbitLine.userData.originalColor = earthOrbitLine.material.color.clone();
orbitObjects.push(earthOrbitLine);
scene.add(earthOrbitLine);

/* ======= UI Y SELECCI√ìN ======= */
const bodySelector = document.getElementById('body-selector');
function populateBodySelector(){
    const prev = bodySelector.value;
    bodySelector.innerHTML='';
    const planetObjects = planets.map(p => p.planet);
    const objs = [sun, ...planetObjects, earth, moon, ...asteroids.filter(a=>isAsteroidVisibleByFilter(a)).map(a=>a.marker)];
    objs.forEach(obj=>{ if (!obj) return; const op=document.createElement('option'); op.value=obj.userData.id; op.textContent=obj.userData.name; bodySelector.appendChild(op); });
    if (prev && [...bodySelector.options].some(o=>o.value===prev)) bodySelector.value=prev;
}
populateBodySelector();
let selectedObject = null;
let followSelected = true;
document.getElementById('follow-toggle').addEventListener('change', e=>{ followSelected = e.target.checked; });
const selectionNameDiv = document.getElementById('selection-name');
const selectionInfoDetailsDiv = document.getElementById('selection-info-details');
const selectionMiniMapDiv = document.getElementById('selection-mini-map');
function selectObject(object) {
    if (!object) return;
    selectedObject = object;
    if ([...bodySelector.options].some(o => o.value === object.userData.id)) { bodySelector.value = object.userData.id; }
    selectionNameDiv.innerText = object.userData.name || '';
    selectionInfoDetailsDiv.innerHTML = object.userData.info || '';
    selectionMiniMapDiv.innerHTML = '';
    if (object.userData.texture) {
        const img = document.createElement('img');
        img.src = object.userData.texture;
        img.className = object.userData.isAsteroid ? 'irregular' : 'circle';
        selectionMiniMapDiv.appendChild(img);
    } else if (object.userData.symbol) {
        const span = document.createElement('span');
        span.className = 'symbol';
        span.innerText = object.userData.symbol;
        selectionMiniMapDiv.appendChild(span);
    }
    const targetPosition = new THREE.Vector3();
    object.getWorldPosition(targetPosition);
    let zoomDistance = asteroids.some(a => a.marker === object) ? 15 : (object === sun ? 400 : 150);
    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
    const newCameraPosition = targetPosition.clone().add(direction.multiplyScalar(zoomDistance));
    controls.target.copy(targetPosition);
    camera.position.copy(newCameraPosition);
    camera.lookAt(targetPosition);
}
bodySelector.addEventListener('change', e=>{
    const id = e.target.value;
    const planetObjects = planets.map(p => p.planet);
    const found = [sun, ...planetObjects, earth, moon, ...asteroids.filter(a=>isAsteroidVisibleByFilter(a)).map(a=>a.marker)].find(o=>o.userData.id===id);
    if (found) selectObject(found);
});

/* ======= PANEL DE CONTROL Y TIEMPO ======= */
const nasaPanel = document.getElementById('nasa-panel');
document.getElementById('toggle-nasa-panel-btn').addEventListener('click', ()=> nasaPanel.classList.add('open'));
document.getElementById('close-nasa-panel').addEventListener('click', ()=> nasaPanel.classList.remove('open'));
const asteroidListDiv = document.getElementById('asteroidList');
const creationWrapper  = document.getElementById('creation-controls-wrapper');
document.getElementById('show-creation-card').addEventListener('click', ()=>{
    document.getElementById('contenedor-asteroides').style.display='none';
    creationWrapper.style.display='block';
    updateDangerAssessment();
});
document.getElementById('back-to-list-btn').addEventListener('click', ()=>{
    document.getElementById('contenedor-asteroides').style.display='block';
    creationWrapper.style.display='none';
});
document.getElementById('asteroid-visual-mode').addEventListener('change', (e)=>{ asteroidVisualMode = e.target.value; });
document.getElementById('clear-asteroids-btn').addEventListener('click', clearAllAsteroids);
document.getElementById('draw-all-orbits-btn').addEventListener('click', async ()=>{ asteroidVisualMode = 'all'; await drawAllAsteroidOrbits(); });
document.getElementById('show-all-now-btn').addEventListener('click', async ()=>{ asteroidVisualMode = 'all'; await showAllAtOnce(); });
const dateDisplay = document.getElementById('date-display');
const playPauseBtn = document.getElementById('play-pause-btn');
const playIcon = playPauseBtn.querySelector('.icon-play');
const pauseIcon = playPauseBtn.querySelector('.icon-pause');
document.getElementById('play-pause-btn').addEventListener('click', ()=>{
    isPaused = !isPaused;
    pauseIcon.style.display = isPaused ? 'none' : 'block';
    playIcon.style.display = isPaused ? 'block' : 'none';
    if (!isPaused) isLive = false;
});
document.getElementById('rewind-btn').addEventListener('click', ()=>{ isLive = false; timeScale = Math.max(1, timeScale/2); syncTimeSliderFromTimeScale(); });
document.getElementById('fast-forward-btn').addEventListener('click', ()=>{ isLive = false; timeScale *= 2; syncTimeSliderFromTimeScale(); });
document.getElementById('live-btn').addEventListener('click', ()=>{ isLive = true; isPaused = false; timeScale = 86400; pauseIcon.style.display = 'block'; playIcon.style.display = 'none'; syncTimeSliderFromTimeScale(); });
function timeScaleFromSlider(v){ const factor = 84; return Math.round(Math.pow(2, v) * factor); }
function sliderFromTimeScale(ts){ const factor=84; return Math.max(0, Math.min(12, Math.log(ts/factor)/Math.log(2))); }
function prettyTimeScale(ts){
    const dps = ts/86400; if (dps>=1) return `x${dps.toFixed(1)} d/s`;
    const hps = ts/3600; if (hps>=1) return `x${hps.toFixed(1)} h/s`;
    const mps = ts/60;   if (mps>=1) return `x${mps.toFixed(1)} min/s`;
    return `x${ts.toFixed(0)} s/s`;
}
function syncTimeSliderFromTimeScale(){
    const v = sliderFromTimeScale(timeScale);
    timeSlider.value = String(Math.round(v));
    timeSpeedLabel.textContent = prettyTimeScale(timeScale);
}
syncTimeSliderFromTimeScale();
function updateDateUI(){
    const opts={ year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit' };
    let ds = simulationDate.toLocaleDateString('es-ES', opts).replace(',', '');
    dateDisplay.innerHTML = isLive && !isPaused ? `${ds} <span id="live-indicator">LIVE</span>` : `${ds} (${prettyTimeScale(timeScale)})`;
}

/* ======= BUCLE DE ANIMACI√ìN PRINCIPAL ======= */
const OBLIQUITY = THREE.MathUtils.degToRad(23.44);
const J2000_EPOCH_MS = 946684800000;
const SIDEREAL_YEAR_MS = 365.256363004 * 86400000;
const J2000_ECLIPTIC_LONGITUDE_OFFSET_RAD = THREE.MathUtils.degToRad(100.46);
const SIDEREAL_DAY_SEC = 86164.0905;
const EARTH_ROTATION_RATE_RAD_PER_S = (2 * Math.PI) / SIDEREAL_DAY_SEC;
const LUNAR_SIDEREAL_DAYS = 27.321661;
const LUNAR_SIDEREAL_SEC = LUNAR_SIDEREAL_DAYS * 86400;
const MOON_INCLINATION_DEG = 5.145;
const clock = new THREE.Clock();

function handleOrbitHover() {
    raycaster.setFromCamera(new THREE.Vector2((mousePos.x / window.innerWidth) * 2 - 1, -(mousePos.y / window.innerHeight) * 2 + 1), camera);
    const orbitHits = raycaster.intersectObjects(orbitObjects, false);

    if (hoveredOrbit && (!orbitHits.length || orbitHits[0].object !== hoveredOrbit)) {
        hoveredOrbit.material.opacity = 0.4;
        hoveredOrbit.material.color.copy(hoveredOrbit.userData.originalColor);
        document.body.style.cursor = 'default';
        hoveredOrbit = null;
    }

    if (orbitHits.length > 0 && orbitHits[0].object !== hoveredOrbit) {
        hoveredOrbit = orbitHits[0].object;
        hoveredOrbit.material.opacity = 1.0;
        hoveredOrbit.material.color.set(0xffffff);
        document.body.style.cursor = 'pointer';
    }
}

function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if (!isPaused) {
        if (isLive) simulationDate = new Date();
        else simulationDate.setTime(simulationDate.getTime() + delta * 1000 * timeScale);
    }
    updateDateUI();
    
    if (distancePlotContainer && distancePlotContainer.style.display !== 'none') {
        updateTimeMarker();
    }

    const elapsedMs = simulationDate.getTime() - J2000_EPOCH_MS;
    
    const earthOrbitalAngle = ((elapsedMs / SIDEREAL_YEAR_MS) * 2 * Math.PI) + J2000_ECLIPTIC_LONGITUDE_OFFSET_RAD;
    earthGroup.position.set(Math.cos(earthOrbitalAngle) * earthOrbitRadius, 0, Math.sin(earthOrbitalAngle) * earthOrbitRadius);
    
    const elapsedSec = elapsedMs / 1000;
    const GMST_J2000_RAD = THREE.MathUtils.degToRad(280.4606);
    const spin = GMST_J2000_RAD + (elapsedSec * EARTH_ROTATION_RATE_RAD_PER_S);
    
    earth.rotation.order = 'ZYX';
    earth.rotation.set(0, spin, OBLIQUITY);
    
    cloudMesh.rotation.y = spin * 0.95;
    
    const tsec = simulationDate.getTime() / 1000.0;
    const lunarAngle = ((tsec % LUNAR_SIDEREAL_SEC) / LUNAR_SIDEREAL_SEC) * Math.PI * 2;
    const inc = THREE.MathUtils.degToRad(MOON_INCLINATION_DEG);
    const julianCenturies = elapsedMs / 3155760000000;
    const Omega_deg = 125.04452 - 1934.136261 * julianCenturies;
    const Omega = THREE.MathUtils.degToRad(Omega_deg);
    const r = moonOrbitRadius;
    let x_m = r * Math.cos(lunarAngle), y_m = 0, z_m = r * Math.sin(lunarAngle);
    let y1 = y_m * Math.cos(inc) - z_m * Math.sin(inc), z1 = y_m * Math.sin(inc) + z_m * Math.cos(inc), x1 = x_m;
    let x2 = x1 * Math.cos(Omega) - z1 * Math.sin(Omega), z2 = x1 * Math.sin(Omega) + z1 * Math.cos(Omega);
    
    moon.position.set(x2, y1, z2);
    moon.lookAt(earth.position);
    moon.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.PI);

    planets.forEach(planetObj => {
        const data = planetObj.data;
        const elapsedDays = elapsedMs / 86400000;
        const orbitalAngle = (elapsedDays / data.period) * 2 * Math.PI;
        const orbitRadius = data.distance * 200;
        
        planetObj.group.position.set(
            Math.cos(orbitalAngle) * orbitRadius,
            0,
            Math.sin(orbitalAngle) * orbitRadius
        );
    });

    const sunPos = sun.getWorldPosition(new THREE.Vector3());
    if (earth?.material?.uniforms?.lightPos) earth.material.uniforms.lightPos.value.copy(sunPos);

    for (const a of asteroids) {
        const visByFilter = isAsteroidVisibleByFilter(a);
        if (a.orbit) a.orbit.visible = visibility.astOrbits && visByFilter;
        if (a.marker) a.marker.visible = visibility.astMarkers && visByFilter;
        if (a.kind === 'real' && a.elements) {
            const el = a.elements;
            const JD_UNIX_EPOCH = 2440587.5, nowJD = (simulationDate.getTime() / 86400000) + JD_UNIX_EPOCH, dt = nowJD - el.epoch;
            const GAUSS_K = 0.01720209895, MU_SUN = GAUSS_K * GAUSS_K, n = Math.sqrt(MU_SUN / (el.a ** 3)), M = el.M0 + n * dt;
            let E = (el.e < 0.8) ? M : Math.PI;
            for (let k = 0; k < 15; k++) { const f = E - el.e * Math.sin(E) - M, fp = 1 - el.e * Math.cos(E); E = E - f / fp; }
            const cosE = Math.cos(E), sinE = Math.sin(E), nu = Math.atan2(Math.sqrt(1 - el.e ** 2) * sinE, cosE - el.e);
            const rK = el.a * (1 - el.e * cosE);
            let xk = rK * Math.cos(nu), yk = rK * Math.sin(nu);
            const cw = Math.cos(el.w), sw = Math.sin(el.w), cO = Math.cos(el.omega), sO = Math.sin(el.omega), ci = Math.cos(el.i), si = Math.sin(el.i);
            let x1r = cw * xk - sw * yk, y1r = sw * xk + cw * yk;
            let x2r = x1r, y2r = ci * y1r, z2r = si * y1r;
            let X = cO * x2r - sO * y2r, Y = sO * x2r + cO * y2r, Z = z2r;
            if (a.marker) a.marker.position.set(X * (earthOrbitRadius / 1.0), Z * (earthOrbitRadius / 1.0), Y * (earthOrbitRadius / 1.0));
        } else if (a.kind === 'sim' && a.params) {
            a.theta += a.params.speed * delta;
            const inc_sim = THREE.MathUtils.degToRad(a.params.inclination);
            const x_sim = a.params.radiusX * Math.cos(a.theta), zf_sim = a.params.radiusZ * Math.sin(a.theta);
            const y_sim = zf_sim * Math.sin(inc_sim), z_sim = zf_sim * Math.cos(inc_sim);
            if (a.marker) a.marker.position.set(x_sim, y_sim, z_sim);
        }
    }
    planets.forEach(p => {
        p.planet.visible = visibility.planets;
        p.orbit.visible = visibility.planetOrbits;
    });
    
    sun.visible = visibility.sun; earth.visible = visibility.earth; moon.visible = visibility.moon; earthOrbitLine.visible = visibility.earthOrbit;
    if (followSelected && selectedObject) {
        const targetNow = new THREE.Vector3(); selectedObject.getWorldPosition(targetNow);
        const nextTarget = controls.target.clone().lerp(targetNow, 0.20);
        const deltaT = nextTarget.clone().sub(controls.target);
        camera.position.add(deltaT);
        controls.target.copy(nextTarget);
    }
    controls.update();
    updateLabels();
    handleOrbitHover();
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
}


/* ======= INTERFAZ Y VISIBILIDAD ======= */
document.getElementById('vis-sun').addEventListener('change', e=> visibility.sun=e.target.checked);
document.getElementById('vis-planets').addEventListener('change', e=> visibility.planets=e.target.checked);
document.getElementById('vis-earth').addEventListener('change', e=> visibility.earth=e.target.checked);
document.getElementById('vis-moon').addEventListener('change', e=> visibility.moon=e.target.checked);
document.getElementById('vis-planet-orbits').addEventListener('change', e=> visibility.planetOrbits=e.target.checked);
document.getElementById('vis-earth-orbit').addEventListener('change', e=> visibility.earthOrbit=e.target.checked);
document.getElementById('vis-ast-orbits').addEventListener('change', e=> { visibility.astOrbits=e.target.checked; applyFilters(); });
document.getElementById('vis-ast-markers').addEventListener('change', e=> { visibility.astMarkers=e.target.checked; applyFilters(); });
document.getElementById('vis-labels').addEventListener('change', e=> { visibility.labels=e.target.checked; });

/* ======= √çNDICE DE PELIGRO "D" ======= */
const DANGER_CONSTANTS = {
    G: 6.67430e-11, M_t: 5.972e24, R_t: 6.371e6, V_esc: 11186, SCENE_UNIT_TO_M: 7.48e8,
    AU: 1.496e11,
    MU_SUN: 1.327e20,
    MU_EARTH: 3.986e14
};
function calculateOrbitalVelocity(keplerianElements) {
    const { a, e } = keplerianElements;
    const { MU_SUN, AU } = DANGER_CONSTANTS;
    const a_meters = a * AU;
    const r_perihelion = a_meters * (1 - e);
    const v_perihelion = Math.sqrt(MU_SUN * (2/r_perihelion - 1/a_meters));
    const r_afelio = a_meters * (1 + e);
    const v_afelio = Math.sqrt(MU_SUN * (2/r_afelio - 1/a_meters));
    const v_average = Math.sqrt(MU_SUN / a_meters);
    return {
        perihelion: v_perihelion,
        afelio: v_afelio,
        average: v_average,
        perihelion_km_s: v_perihelion / 1000,
        afelio_km_s: v_afelio / 1000,
        average_km_s: v_average / 1000
    };
}

function calculateOrbitalPosition(keplerianElements, timeDays = 0) {
    try {
        const { a, e, i, omega, Omega, M } = keplerianElements;
        const { AU } = DANGER_CONSTANTS;
        if (!a || a <= 0 || e < 0 || e >= 1) return { x: 0, y: 0, z: 0, r: 0, nu: 0, E: 0 };
        const n = Math.sqrt(DANGER_CONSTANTS.MU_SUN / Math.pow(a * AU, 3));
        const M_current = M + n * timeDays * 86400;
        let E = M_current;
        for (let iter = 0; iter < 20; iter++) {
            const f = E - e * Math.sin(E) - M_current;
            const f_prime = 1 - e * Math.cos(E);
            if (Math.abs(f_prime) < 1e-10) break;
            E = E - f / f_prime;
            if (Math.abs(f) < 1e-8) break;
        }
        const nu = Math.atan2(Math.sqrt(1 - e*e) * Math.sin(E), Math.cos(E) - e);
        const r = a * AU * (1 - e * Math.cos(E));
        const x_orbital = r * Math.cos(nu);
        const y_orbital = r * Math.sin(nu);
        const cos_omega = Math.cos(omega), sin_omega = Math.sin(omega);
        const cos_Omega = Math.cos(Omega), sin_Omega = Math.sin(Omega);
        const cos_i = Math.cos(i), sin_i = Math.sin(i);
        const x1 = cos_omega * x_orbital - sin_omega * y_orbital;
        const y1 = sin_omega * x_orbital + cos_omega * y_orbital;
        const x2 = x1;
        const y2 = cos_i * y1;
        const z2 = sin_i * y1;
        const x = cos_Omega * x2 - sin_Omega * y2;
        const y = sin_Omega * x2 + cos_Omega * y2;
        const z = z2;
        return { x, y, z, r, nu, E };
    } catch (error) {
        console.error('Error en calculateOrbitalPosition:', error);
        return { x: 0, y: 0, z: 0, r: 0, nu: 0, E: 0 };
    }
}

function calculateDangerIndexKeplerian(keplerianElements, diameterMeters) {
    try {
        const { R_t, V_esc } = DANGER_CONSTANTS;
        if (!keplerianElements || !diameterMeters || diameterMeters <= 0) return createDefaultDangerInfo();
        const velocities = calculateOrbitalVelocity(keplerianElements);
        if (!velocities || !velocities.perihelion_km_s) return createDefaultDangerInfo();
        const position = calculateOrbitalPosition(keplerianElements, 0);
        if (!position || isNaN(position.x)) return createDefaultDangerInfo();
        const distanceToEarth = Math.sqrt(position.x*position.x + position.y*position.y + position.z*position.z) / DANGER_CONSTANTS.AU;
        const v_orbital = velocities.perihelion_km_s * 1000;
        const kineticEnergy = 0.5 * (4/3 * Math.PI * Math.pow(diameterMeters/2, 3) * 3000) * v_orbital*v_orbital;
        const energyFactor = Math.log10(kineticEnergy / 1e15);
        const distanceFactor = Math.max(0.1, 1 / distanceToEarth);
        const velocityFactor = Math.min(2.0, v_orbital / 30000);
        const D_base = energyFactor * distanceFactor * velocityFactor;
        const massFactor = Math.pow(Math.max(1, diameterMeters) / 140, 1.5);
        const D_final = D_base * massFactor;
        let level, color;
        if (D_final > 2.0) { level = 'AMENAZA CR√çTICA'; color = 'var(--danger-color)'; }
        else if (D_final > 1.0) { level = 'AMENAZA'; color = 'var(--danger-color)'; }
        else if (D_final > 0.5) { level = 'RIESGO ALTO'; color = 'var(--warning-color)'; }
        else if (D_final > 0.2) { level = 'RIESGO MODERADO'; color = 'var(--warning-color)'; }
        else { level = 'SEGURO'; color = 'var(--safe-color)'; }
        return { dangerIndex: D_final, isDangerous: D_final > 0.5, level, color, velocities, distanceToEarth, kineticEnergy };
    } catch (error) {
        console.error('Error en calculateDangerIndexKeplerian:', error);
        return createDefaultDangerInfo();
    }
}

function createDefaultDangerInfo() {
    return {
        dangerIndex: 0.1, isDangerous: false, level: 'SEGURO', color: 'var(--safe-color)',
        velocities: { perihelion_km_s: 0, afelio_km_s: 0, average_km_s: 0 },
        distanceToEarth: 1.0, kineticEnergy: 0
    };
}

function updateDangerAssessment() {
    try {
        const diameter = Number(document.getElementById('diameter')?.value || 0);
        const panel = document.getElementById('danger-assessment-minimal');
        if (panel) {
            const keplerianElements = {
                a: Number(document.getElementById('semiMajorAxis').value),
                e: Number(document.getElementById('eccentricity').value),
                i: THREE.MathUtils.degToRad(Number(document.getElementById('inclination').value)),
                omega: THREE.MathUtils.degToRad(Number(document.getElementById('argumentPerihelion').value)),
                Omega: THREE.MathUtils.degToRad(Number(document.getElementById('longitudeNode').value)),
                M: THREE.MathUtils.degToRad(Number(document.getElementById('meanAnomaly').value))
            };
            const assessment = calculateDangerIndexKeplerian(keplerianElements, diameter);
            panel.textContent = assessment.level;
            panel.style.backgroundColor = assessment.color.replace('var(', 'rgba(').replace(')',', 0.2)');
            panel.style.color = assessment.color;
            panel.style.border = `1px solid ${assessment.color}`;
        }
    } catch (error) {
        console.error('Error en updateDangerAssessment:', error);
    }
}

/* ======= ASTEROIDES SIMULADOS ======= */
const asteroidGlowToggle = document.getElementById('asteroid-glow-toggle');
let asteroidGlowActive = false;
function applyAsteroidGlow(asteroid, active) {
    if (!asteroid?.marker?.material) return;
    if (active) {
        asteroid.marker.material.emissive = new THREE.Color(0xffffff);
        asteroid.marker.material.emissiveIntensity = 2.5;
    } else {
        asteroid.marker.material.emissive = new THREE.Color(0x000000);
        asteroid.marker.material.emissiveIntensity = 1.0;
    }
    asteroid.marker.material.needsUpdate = true;
}
function updateAllAsteroidGlows() {
    asteroidGlowActive = asteroidGlowToggle.checked;
    asteroids.forEach(a => applyAsteroidGlow(a, asteroidGlowActive));
}
function createIrregularAsteroidGeometry() {
    const geometry = new THREE.SphereGeometry(0.35, 32, 32);
    const pos = geometry.getAttribute('position');
    const v = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        v.multiplyScalar(1 + (Math.random() - 0.5) * 0.15);
        pos.setXYZ(i, v.x, v.y, v.z);
    }
    geometry.computeVertexNormals();
    geometry.computeBoundingSphere();
    return geometry;
}
let semiMajorAxisSlider, eccentricitySlider, inclinationSlider, longitudeNodeSlider, argumentPerihelionSlider, meanAnomalySlider, diameterSlider;
let semiMajorAxisValue, eccentricityValue, inclinationValue, longitudeNodeValue, argumentPerihelionValue, meanAnomalyValue, diameterValue;

function initializeKeplerianElements() {
    semiMajorAxisSlider = document.getElementById('semiMajorAxis');
    eccentricitySlider = document.getElementById('eccentricity');
    inclinationSlider = document.getElementById('inclination');
    longitudeNodeSlider = document.getElementById('longitudeNode');
    argumentPerihelionSlider = document.getElementById('argumentPerihelion');
    meanAnomalySlider = document.getElementById('meanAnomaly');
    diameterSlider = document.getElementById('diameter');
    semiMajorAxisValue = document.getElementById('semiMajorAxis-value');
    eccentricityValue = document.getElementById('eccentricity-value');
    inclinationValue = document.getElementById('inclination-value');
    longitudeNodeValue = document.getElementById('longitudeNode-value');
    argumentPerihelionValue = document.getElementById('argumentPerihelion-value');
    meanAnomalyValue = document.getElementById('meanAnomaly-value');
    diameterValue = document.getElementById('diameter-value');
}

function updateSimValues() {
    semiMajorAxisValue.textContent = `${Number(semiMajorAxisSlider.value).toFixed(2)} AU`;
    eccentricityValue.textContent = `${Number(eccentricitySlider.value).toFixed(2)}`;
    inclinationValue.textContent = `${Number(inclinationSlider.value)}¬∞`;
    longitudeNodeValue.textContent = `${Number(longitudeNodeSlider.value)}¬∞`;
    argumentPerihelionValue.textContent = `${Number(argumentPerihelionSlider.value)}¬∞`;
    meanAnomalyValue.textContent = `${Number(meanAnomalySlider.value)}¬∞`;
    const diameterMeters = Number(diameterSlider.value);
    diameterValue.textContent = diameterMeters < 1000 ? `${diameterMeters} m` : `${(diameterMeters / 1000).toFixed(2)} km`;
    
    const keplerianElements = {
        a: Number(semiMajorAxisSlider.value),
        e: Number(eccentricitySlider.value),
        i: THREE.MathUtils.degToRad(Number(inclinationSlider.value)),
        omega: THREE.MathUtils.degToRad(Number(argumentPerihelionSlider.value)),
        Omega: THREE.MathUtils.degToRad(Number(longitudeNodeSlider.value)),
        M: THREE.MathUtils.degToRad(Number(meanAnomalySlider.value))
    };
    
    const velocities = calculateOrbitalVelocity(keplerianElements);
    const periodDays = 2 * Math.PI * Math.sqrt(Math.pow(keplerianElements.a * DANGER_CONSTANTS.AU, 3) / DANGER_CONSTANTS.MU_SUN) / 86400;
    const perihelionDistance = keplerianElements.a * (1 - keplerianElements.e);
    const aphelionDistance = keplerianElements.a * (1 + keplerianElements.e);
    
    document.getElementById('orbital-details').innerHTML = `
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
            <div><strong>Perihelio:</strong> ${perihelionDistance.toFixed(2)} AU</div>
            <div><strong>Afelio:</strong> ${aphelionDistance.toFixed(2)} AU</div>
            <div><strong>V. Perihelio:</strong> ${velocities.perihelion_km_s.toFixed(1)} km/s</div>
            <div><strong>V. Afelio:</strong> ${velocities.afelio_km_s.toFixed(1)} km/s</div>
            <div><strong>V. Promedio:</strong> ${velocities.average_km_s.toFixed(1)} km/s</div>
            <div><strong>Per√≠odo:</strong> ${periodDays.toFixed(1)} d√≠as</div>
        </div>`;
    
    updateDangerAssessmentKeplerian(keplerianElements, diameterMeters);
}

function updateDangerAssessmentKeplerian(keplerianElements, diameterMeters) {
    const assessment = calculateDangerIndexKeplerian(keplerianElements, diameterMeters);
    const panel = document.getElementById('danger-assessment-minimal');
    panel.textContent = assessment.level;
    panel.style.backgroundColor = assessment.color.replace('var(', 'rgba(').replace(')',', 0.2)');
    panel.style.color = assessment.color;
    panel.style.border = `1px solid ${assessment.color}`;
}

function setupKeplerianEventListeners() {
    [semiMajorAxisSlider, eccentricitySlider, inclinationSlider, longitudeNodeSlider, argumentPerihelionSlider, meanAnomalySlider, diameterSlider].forEach(slider => {
        if(slider) slider.addEventListener('input', updateSimValues);
    });
}

function addSimulatedAsteroid(keplerianElements, diameterMeters, dangerInfo){
    if (asteroidVisualMode === 'single') clearAllAsteroids();
    dangerInfo = dangerInfo || createDefaultDangerInfo();
    const isDangerous = dangerInfo.isDangerous || false;
    const orbitColor = isDangerous ? 0xFF4D4D : 0x00FFFF;
    
    const orbit = createKeplerianOrbit(keplerianElements, orbitColor);
    const marker = new THREE.Mesh(createIrregularAsteroidGeometry(), new THREE.MeshStandardMaterial({ map: asteroidTex, roughness: 0.8, metalness: 0.2, color: isDangerous ? 0xff8888 : 0xffffff }));
    
    const scale = Math.max(0.01, (diameterMeters / 1000) / 0.7);
    marker.scale.set(scale, scale, scale);
    
    orbit.userData.celestialBody = marker;
    orbit.userData.originalColor = orbit.material.color.clone();
    orbitObjects.push(orbit);
    
    const initialPosition = calculateOrbitalPosition(keplerianElements, 0);
    const initialX = initialPosition.x / DANGER_CONSTANTS.AU * 200;
    const initialY = initialPosition.z / DANGER_CONSTANTS.AU * 200;
    const initialZ = initialPosition.y / DANGER_CONSTANTS.AU * 200;
    marker.position.set(initialX, initialY, initialZ);
    
    scene.add(orbit);
    scene.add(marker);
    clickableObjects.push(marker);
    
    const simName = `Simulado${isDangerous ? ' (AMENAZA)' : ''}`;
    const diameterText = diameterMeters < 1000 ? `${diameterMeters} m` : `${(diameterMeters / 1000).toFixed(2)} km`;
    const periodDays = 2 * Math.PI * Math.sqrt(Math.pow(keplerianElements.a * DANGER_CONSTANTS.AU, 3) / DANGER_CONSTANTS.MU_SUN) / 86400;

    marker.userData = { id:`sim_${Date.now()}`, name: simName, info: `<p><strong>√ìrbita Simulada</strong></p><p>Di√°metro: <span class="valor">${diameterText}</span></p><p>Per√≠odo: <span class="valor">${periodDays.toFixed(1)} d√≠as</span></p>`, texture: 'Asteroidemodelo2d.jpg', isAsteroid: true };
    const asteroidLabel = createLabel(simName);
    marker.add(asteroidLabel);
    
    const obj = { 
        id: marker.userData.id, name: simName, orbit, marker, kind:'sim', hazardous: isDangerous, label: asteroidLabel,
        elements: { ...keplerianElements, w: keplerianElements.omega, omega: keplerianElements.Omega, M0: keplerianElements.M, epoch: (new Date().getTime() / 86400000) + 2440587.5 }
    };
    
    asteroids.push(obj);
    applyAsteroidGlow(obj, asteroidGlowActive);
    populateBodySelector();
    populatePredictionSelector(); 
    selectObject(marker);
}

function createKeplerianOrbit(keplerianElements, color) {
    const points = [];
    const numPoints = 200;
    for (let i = 0; i <= numPoints; i++) {
        const angle = (i / numPoints) * 2 * Math.PI;
        const position = calculateOrbitalPosition({ ...keplerianElements, M: angle });
        if (!isNaN(position.x)) {
            const x = position.x / DANGER_CONSTANTS.AU * 200;
            const y = position.z / DANGER_CONSTANTS.AU * 200;
            const z = position.y / DANGER_CONSTANTS.AU * 200;
            if(!isNaN(x)) points.push(new THREE.Vector3(x, y, z));
        }
    }
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    return new THREE.Line(geometry, new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.6 }));
}

document.getElementById('launchAsteroid').addEventListener('click', ()=>{
    const keplerianElements = {
        a: Number(semiMajorAxisSlider.value),
        e: Number(eccentricitySlider.value),
        i: THREE.MathUtils.degToRad(Number(inclinationSlider.value)),
        omega: THREE.MathUtils.degToRad(Number(argumentPerihelionSlider.value)),
        Omega: THREE.MathUtils.degToRad(Number(longitudeNodeSlider.value)),
        M: THREE.MathUtils.degToRad(Number(meanAnomalySlider.value))
    };
    const diameterMeters = Number(diameterSlider.value);
    const dangerInfo = calculateDangerIndexKeplerian(keplerianElements, diameterMeters);
    addSimulatedAsteroid(keplerianElements, diameterMeters, dangerInfo);
});


/* ======= ASTEROIDES REALES (NASA) ======= */
const NASA_API_KEY = "d08i3FBbUZzcgtCggtbY3u9LjUhFie4WaFmdk6d7";
async function fetchNasaData() {
  const statusDiv = document.getElementById('nasa-status'), listDiv = document.getElementById('asteroidList');
  listDiv.innerHTML = ''; statusDiv.style.display = 'block'; statusDiv.textContent = 'Cargando asteroides...';
  const today = new Date(), start = new Date(today.getTime() - 2*864e5), end = new Date(today.getTime() + 2*864e5);
  const fmt = d => d.toISOString().split('T')[0];
  const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${fmt(start)}&end_date=${fmt(end)}&api_key=${NASA_API_KEY}`;
  try {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const data = await r.json();
    const all = Object.values(data.near_earth_objects).flat();
    all.sort((a,b) => a.close_approach_data[0].miss_distance.kilometers - b.close_approach_data[0].miss_distance.kilometers);
    lastFetchedNeoIds = all.map(a=>a.id);
    statusDiv.style.display = 'none';
    
    for (const neo of all) {
      const card = document.createElement('div');
      card.className = 'asteroide-card' + (neo.is_potentially_hazardous_asteroid ? ' peligroso':'');
      const d = neo.estimated_diameter.meters.estimated_diameter_max.toFixed(1);
      const cad = neo.close_approach_data[0];
      card.innerHTML = `<h3>${neo.name} ${neo.is_potentially_hazardous_asteroid ? '<span style="color:#ff4d6d">PHA</span>':''}</h3><p>Fecha: <strong>${cad.close_approach_date_full}</strong></p><p>Di√°metro: <strong>${d} m</strong></p><p>Pasa a: <strong>${parseFloat(cad.miss_distance.kilometers).toLocaleString('es-ES',{maximumFractionDigits:0})} km</strong></p>`;
      card.addEventListener('click', () => loadNeoDetails(neo.id, neo.name));
      listDiv.appendChild(card);
    }
    warmNeoCache(lastFetchedNeoIds);
    if (all.length === 0) { statusDiv.textContent = 'No se encontraron asteroides.'; }
    populatePredictionSelector();
  } catch (e) {
    statusDiv.textContent = 'No se pudieron cargar los datos de la NASA.';
  }
}
async function warmNeoCache(ids, concurrency=6){
  const queue = [...ids]; let idx = 0;
  async function worker(){ while(idx < queue.length){ const id = queue[idx++]; if (neoCache.has(id)) continue; try{ const det = await fetchNeoDetail(id); neoCache.set(id, { detail: det, ts: Date.now() }); }catch(e){} await new Promise(r=>setTimeout(r,100)); } }
  await Promise.all(Array.from({length:Math.min(concurrency, queue.length)}, ()=>worker()));
  saveLSCache();
}
async function fetchNeoDetail(id){ const r = await fetch(`https://api.nasa.gov/neo/rest/v1/neo/${id}?api_key=${NASA_API_KEY}`); if(!r.ok) throw new Error(`HTTP ${r.status}`); return await r.json(); }
async function getNeoDetail(id){
  if (neoCache.has(id)) { const pack = neoCache.get(id); if (Date.now() - pack.ts < TTL_MS) return pack.detail; }
  const det = await fetchNeoDetail(id); neoCache.set(id, { detail: det, ts: Date.now() }); saveLSCache(); return det;
}
async function drawAllAsteroidOrbits(concurrency=5){
  if (!lastFetchedNeoIds.length) return; asteroidVisualMode = 'all';
  const workers = []; for(let i=0; i<Math.min(concurrency, lastFetchedNeoIds.length); ++i) { workers.push((async () => { for(let j=i; j<lastFetchedNeoIds.length; j+=concurrency) await loadNeoDetails(lastFetchedNeoIds[j], 'NEO'); })()); }
  await Promise.all(workers); applyFilters();
}
async function showAllAtOnce(concurrency=6){
    if (!lastFetchedNeoIds.length) await fetchNasaData();
    if (!lastFetchedNeoIds.length) return;
    asteroidVisualMode = 'all';
    await drawAllAsteroidOrbits(concurrency);
}
async function loadNeoDetails(neoId, fallbackName = 'Asteroide') {
    if (asteroidVisualMode === 'single') clearAllAsteroids();
    try {
        const detail = await getNeoDetail(neoId);
        const od = detail.orbital_data;
        const el = { a: Number(od.semi_major_axis), e: Number(od.eccentricity), i: THREE.MathUtils.degToRad(Number(od.inclination)), omega: THREE.MathUtils.degToRad(Number(od.ascending_node_longitude)), w: THREE.MathUtils.degToRad(Number(od.perihelion_argument)), M0: THREE.MathUtils.degToRad(Number(od.mean_anomaly)), epoch: Number(od.epoch_osculation) };
        addOrUpgradeRealAsteroid(neoId, el, detail, !!detail.is_potentially_hazardous_asteroid);
    } catch (e) { console.error('Error al obtener detalles del NEO:', e); }
}
function addOrUpgradeRealAsteroid(neoId, el, neoDetails, hazardous = false) {
    let record = asteroids.find(a => a.userDataId === neoId);
    if (!record) {
        const marker = new THREE.Mesh(createIrregularAsteroidGeometry(), new THREE.MeshStandardMaterial({ map: asteroidTex, roughness: 0.8, metalness: 0.2, color: hazardous ? 0xff8888 : 0xffffff }));
        scene.add(marker); clickableObjects.push(marker);
        const label = createLabel(neoDetails.name); marker.add(label);
        marker.userData = { id: `neo_${neoId}`, name: neoDetails.name, texture: 'Asteroidemodelo2d.jpg', isAsteroid: true };
        record = { userDataId: neoId, name: neoDetails.name, marker, kind: 'real', hazardous, label };
        asteroids.push(record);
    }
    const color = hazardous ? 0xFF4D4D : 0x00FFFF;
    const pts = [];
    for (let k = 0; k <= 512; k++) {
        const nu = (k / 512) * Math.PI * 2, r = el.a * (1 - el.e ** 2) / (1 + el.e * Math.cos(nu));
        let x = r * Math.cos(nu), y = r * Math.sin(nu);
        const cw=Math.cos(el.w), sw=Math.sin(el.w), cO=Math.cos(el.omega), sO=Math.sin(el.omega), ci=Math.cos(el.i), si=Math.sin(el.i);
        let x1=cw*x - sw*y, y1=sw*x + cw*y; let x2=x1, y2=ci*y1, z2=si*y1;
        let X=cO*x2-sO*y2, Y=sO*x2+cO*y2, Z=z2;
        pts.push(new THREE.Vector3(X * earthOrbitRadius, Z * earthOrbitRadius, Y * earthOrbitRadius));
    }
    const orbit = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.25 }));
    
    if (record.orbit) scene.remove(record.orbit);
    orbit.userData.celestialBody = record.marker;
    scene.add(orbit);
    Object.assign(record, { elements: el, name: neoDetails.name, orbit, hazardous, neoDetails });
    record.marker.userData.name = neoDetails.name;
    record.marker.userData.info = `<p><b>${neoDetails.name}</b>${hazardous ? ' <span style="color:var(--danger-color)">(PHA)</span>' : ''}</p><p>Objeto real (NEO).</p>`;
    record.label.element.textContent = neoDetails.name;
    
    applyAsteroidGlow(record, asteroidGlowActive);
    applyFilters(); populateBodySelector();
    populatePredictionSelector(); 
    if (!selectedObject || asteroidVisualMode === 'single') selectObject(record.marker);
}

/* ======= FILTROS Y UTILIDADES ======= */
function isAsteroidVisibleByFilter(a){
    if (!a) return false;
    if (filterOnlyPHA.checked) return !!a.hazardous;
    if (filterHideNonPHA.checked) return a.hazardous || a.kind === 'sim';
    return true;
}
function applyFilters(){
    asteroids.forEach(a => {
        const vis = isAsteroidVisibleByFilter(a);
        if (a.marker) a.marker.visible = visibility.astMarkers && vis;
        if (a.orbit) a.orbit.visible = visibility.astOrbits && vis;
    });
    document.querySelectorAll('#asteroidList .asteroide-card').forEach(card => {
        const isPHA = card.querySelector('h3')?.textContent.includes('PHA');
        card.style.display = (filterOnlyPHA.checked && !isPHA) || (filterHideNonPHA.checked && !isPHA) ? 'none' : '';
    });
    populateBodySelector();
}
function clearAllAsteroids(){
    while(asteroids.length){
        const a = asteroids.pop();
        if (a.orbit) scene.remove(a.orbit);
        if (a.marker){
            scene.remove(a.marker);
            clickableObjects = clickableObjects.filter(o=>o!==a.marker);
        }
    }
    populateBodySelector();
    populatePredictionSelector();
}

/* ======= AN√ÅLISIS DE DISTANCIA Y GR√ÅFICOS ======= */
let meteorSelector, plotDistanceBtn, distancePlotContainer, distancePlotCanvas;
let currentTimeScale = 260;
let currentTimeOffset = 0;
let currentAsteroid = null;

function calculateCriticalRadius(velocityNearEarth) {
    const { R_t, V_esc } = DANGER_CONSTANTS;
    if (velocityNearEarth <= 0) return R_t / 1000;
    return (Math.sqrt(R_t * R_t * (1 + (V_esc * V_esc) / (velocityNearEarth * velocityNearEarth)))) / 1000;
}

function updateMeteorSelector() {
    if (!meteorSelector) return;
    const prev = meteorSelector.value;
    const statusDiv = document.getElementById('meteor-status');
    meteorSelector.innerHTML = '<option value="">üîç Seleccionar meteoro...</option>';
    if (asteroids.length === 0) {
        statusDiv.textContent = 'Sin datos';
    } else {
        asteroids.forEach(a => {
            const userData = a.userData || a.marker?.userData;
            if(userData?.name && userData?.id){
                const option = document.createElement('option');
                option.value = userData.id;
                option.textContent = `${a.hazardous ? '‚ö†Ô∏è' : '‚òÑÔ∏è'} ${userData.name}`;
                meteorSelector.appendChild(option);
            }
        });
        statusDiv.textContent = `${asteroids.length} disponibles`;
    }
    if (prev && [...meteorSelector.options].some(o => o.value === prev)) {
        meteorSelector.value = prev;
    }
    updateMeteorInfo(meteorSelector.value);
}

function updateMeteorInfo(selectedId) {
    const meteorInfo = document.getElementById('meteor-info');
    const plotBtn = document.getElementById('plot-distance-btn');
    if (!selectedId) {
        meteorInfo.style.display = 'none';
        plotBtn.disabled = true;
        return;
    }
    const asteroid = asteroids.find(a => (a.marker?.userData?.id === selectedId));
    if (!asteroid) {
        meteorInfo.style.display = 'none';
        plotBtn.disabled = true;
        return;
    }
    meteorInfo.querySelector('.meteor-name').textContent = asteroid.marker.userData.name;
    meteorInfo.style.display = 'block';
    plotBtn.disabled = !(asteroid.elements || asteroid.neo);
}

window.toggleDistanceAnalysis = function() {
    const content = document.getElementById('distance-analysis-content');
    content.style.display = content.style.display === 'none' ? 'block' : 'none';
}

function calculateDistanceToEarth(asteroid, timeWeeks) {
    if (!asteroid.elements) return null;
    const { AU, MU_SUN } = DANGER_CONSTANTS;
    const el = asteroid.elements;
    const t_jd = ((new Date().getTime() + timeWeeks * 7 * 864e5) / 864e5) + 2440587.5;
    const dt_days = t_jd - el.epoch;
    const n = Math.sqrt(MU_SUN / (el.a**3 * AU**3));
    const M = el.M0 + n * (dt_days * 86400);
    let E = M;
    for (let k = 0; k < 10; k++) { E = E - (E - el.e * Math.sin(E) - M) / (1 - el.e * Math.cos(E)); }
    const r = el.a * AU * (1 - el.e * Math.cos(E));
    const nu = Math.atan2(Math.sqrt(1 - el.e**2) * Math.sin(E), Math.cos(E) - el.e);
    const x_orb = r * Math.cos(nu), y_orb = r * Math.sin(nu);
    const cos_w = Math.cos(el.w), sin_w = Math.sin(el.w);
    const cos_omega = Math.cos(el.omega), sin_omega = Math.sin(el.omega);
    const cos_i = Math.cos(el.i), sin_i = Math.sin(el.i);
    let x = x_orb * (cos_w * cos_omega - sin_w * sin_omega * cos_i) - y_orb * (sin_w * cos_omega + cos_w * sin_omega * cos_i);
    let y = x_orb * (cos_w * sin_omega + sin_w * cos_omega * cos_i) + y_orb * (-sin_w * sin_omega + cos_w * cos_omega * cos_i);
    let z = x_orb * (sin_w * sin_i) + y_orb * (cos_w * sin_i);
    const asteroidPos = new THREE.Vector3(x, z, y);
    const earthAngle = ((new Date().getTime() + timeWeeks * 7 * 864e5) / SIDEREAL_YEAR_MS) * 2 * Math.PI;
    const earthPos = new THREE.Vector3(Math.cos(earthAngle) * AU, 0, Math.sin(earthAngle) * AU);
    return asteroidPos.distanceTo(earthPos) / 1000;
}

// --- NUEVAS FUNCIONES PARA EL GR√ÅFICO ---
function formatDistance(km) {
    if (km >= 1e6) return `${(km / 1e6).toFixed(1)}M km`;
    if (km >= 1e3) return `${(km / 1e3).toFixed(0)}k km`;
    return `${km.toFixed(0)} km`;
}

function getNiceAxisBounds(min, max, numTicks = 5) {
    const range = max - min;
    if (range === 0) return { niceMin: min - 1, niceMax: max + 1, tickStep: 1 };
    const rawStep = range / (numTicks - 1);
    const magnitude = Math.pow(10, Math.floor(Math.log10(rawStep)));
    const res = rawStep / magnitude;
    let tickStep;
    if (res > 5) tickStep = 10 * magnitude;
    else if (res > 2) tickStep = 5 * magnitude;
    else if (res > 1) tickStep = 2 * magnitude;
    else tickStep = magnitude;
    const niceMin = Math.floor(min / tickStep) * tickStep;
    const niceMax = Math.ceil(max / tickStep) * tickStep;
    return { niceMin, niceMax, tickStep };
}
// --- FIN NUEVAS FUNCIONES ---

function generateDistancePlot(asteroid) {
    currentAsteroid = asteroid;
    const canvas = distancePlotCanvas;
    const ctx = canvas.getContext('2d');
    resizeCanvasToContainer();
    const width = canvas.width, height = canvas.height;
    
    // --- ESTILOS DEL GR√ÅFICO ---
    ctx.fillStyle = 'rgba(10, 15, 20, 0.8)';
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = 'rgba(156, 179, 209, 0.2)'; // color secundario para grid
    ctx.fillStyle = 'rgba(156, 179, 209, 0.8)'; // color secundario para texto
    ctx.font = '11px Roboto';
    const margin = { top: 20, right: 20, bottom: 40, left: 60 };
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;

    const dataPoints = [];
    const startWeek = currentTimeOffset;
    const endWeek = currentTimeOffset + currentTimeScale;

    for (let week = startWeek; week <= endWeek; week += currentTimeScale / 500) {
        const distance = calculateDistanceToEarth(asteroid, week);
        if (distance !== null) dataPoints.push({ week, distance });
    }
    if(dataPoints.length < 2) return;

    const minDistance = Math.min(...dataPoints.map(p => p.distance));
    const maxDistance = Math.max(...dataPoints.map(p => p.distance));
    
    const yAxis = getNiceAxisBounds(minDistance, maxDistance, 6);
    const xAxisTicks = 5;

    // --- DIBUJAR EJES Y GU√çAS ---
    ctx.lineWidth = 1;
    // Gu√≠as horizontales (Y)
    for (let val = yAxis.niceMin; val <= yAxis.niceMax; val += yAxis.tickStep) {
        const y = margin.top + plotHeight - ((val - yAxis.niceMin) / (yAxis.niceMax - yAxis.niceMin)) * plotHeight;
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(width - margin.right, y);
        ctx.stroke();
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(formatDistance(val), margin.left - 8, y);
    }
    // Gu√≠as verticales (X)
    for (let i = 0; i <= xAxisTicks; i++) {
        const week = startWeek + (i / xAxisTicks) * (endWeek - startWeek);
        const x = margin.left + (i / xAxisTicks) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x, height - margin.bottom);
        ctx.stroke();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const yearLabel = (week / 52).toFixed(1);
        ctx.fillText(`${yearLabel}a`, x, height - margin.bottom + 8);
    }

    // --- T√çTULOS DE EJES ---
    ctx.save();
    ctx.translate(15, margin.top + plotHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillText('Distancia (km)', 0, 0);
    ctx.restore();
    ctx.textAlign = 'center';
    ctx.fillText('Tiempo (A√±os desde hoy)', margin.left + plotWidth / 2, height - 10);

    // --- DIBUJAR L√çNEA DE DATOS ---
    ctx.strokeStyle = '#38a9ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    dataPoints.forEach((p, i) => {
        const x = margin.left + ((p.week - startWeek) / (endWeek - startWeek)) * plotWidth;
        const y = margin.top + plotHeight - ((p.distance - yAxis.niceMin) / (yAxis.niceMax - yAxis.niceMin)) * plotHeight;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // --- DIBUJAR MARCADOR DE TIEMPO ACTUAL ---
    const elapsedWeeks = (simulationDate.getTime() - new Date().getTime()) / (7 * 864e5);
    if (elapsedWeeks >= startWeek && elapsedWeeks <= endWeek) {
        const xNow = margin.left + ((elapsedWeeks - startWeek) / (endWeek - startWeek)) * plotWidth;
        ctx.strokeStyle = 'var(--warning-color)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(xNow, margin.top);
        ctx.lineTo(xNow, height - margin.bottom);
        ctx.stroke();
    }

    distancePlotContainer.style.display = 'block';
}
function regeneratePlot() { if (currentAsteroid) generateDistancePlot(currentAsteroid); }
function updateTimeScale() { currentTimeScale = parseInt(document.getElementById('time-scale-selector').value); regeneratePlot(); }
function updateTimeOffset() { currentTimeOffset = parseInt(document.getElementById('time-offset-slider').value); document.getElementById('time-offset-display').textContent = `${currentTimeOffset} semanas`; regeneratePlot(); }
function resetTimeView() { currentTimeOffset = 0; currentTimeScale = 260; document.getElementById('time-offset-slider').value = 0; document.getElementById('time-scale-selector').value = 260; document.getElementById('time-offset-display').textContent = '0 semanas'; regeneratePlot(); }
function centerOnCurrentTime() {
    const elapsedWeeks = (simulationDate.getTime() - new Date().getTime()) / (7 * 864e5);
    currentTimeOffset = Math.max(0, Math.round(elapsedWeeks - currentTimeScale / 2));
    document.getElementById('time-offset-slider').value = currentTimeOffset;
    document.getElementById('time-offset-display').textContent = `${Math.round(currentTimeOffset)} semanas`;
    regeneratePlot();
}
function setupCanvasResizing() {
    const container = distancePlotContainer;
    const canvas = distancePlotCanvas;
    const resizeObserver = new ResizeObserver(() => { if (container.style.display !== 'none') regeneratePlot(); });
    resizeObserver.observe(container);
}
function resizeCanvasToContainer() {
    const containerRect = distancePlotContainer.getBoundingClientRect();
    distancePlotCanvas.width = containerRect.width - 32;
    distancePlotCanvas.height = containerRect.height - 150;
    document.getElementById('plot-size-indicator').textContent = `${Math.round(distancePlotCanvas.width)}√ó${Math.round(distancePlotCanvas.height)}`;
}
function updateTimeMarker() {
    if (distancePlotContainer.style.display !== 'none') regeneratePlot();
}

// ===== C√ìDIGO MODIFICADO: FUNCIONES PARA AN√ÅLISIS DE INTERSECCI√ìN =====
function calcularPosicionTierra(t) {
    const elapsedMs = t.getTime() - J2000_EPOCH_MS;
    const orbitalAngle = ((elapsedMs / SIDEREAL_YEAR_MS) * 2 * Math.PI) + J2000_ECLIPTIC_LONGITUDE_OFFSET_RAD;
    return { x: Math.cos(orbitalAngle), y: 0, z: Math.sin(orbitalAngle) };
}

function calcularPosicionAsteroide(elementos, t) {
    const { AU, MU_SUN } = DANGER_CONSTANTS;
    const a = elementos.a * AU, e = elementos.e, i_rad = elementos.i, omega_rad = elementos.omega, w_rad = elementos.w, M0_rad = elementos.M0, epoch_jd = elementos.epoch;
    const t_jd = (t.getTime() / 86400000) + 2440587.5;
    const dt_days = t_jd - epoch_jd;
    const n = Math.sqrt(MU_SUN / (a**3));
    const M = M0_rad + n * (dt_days * 86400);
    let E = M;
    for (let k = 0; k < 10; k++) { E = E - (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E)); }
    const r = a * (1 - e * Math.cos(E));
    const nu = Math.atan2(Math.sqrt(1 - e**2) * Math.sin(E), Math.cos(E) - e);
    const x_orb = r * Math.cos(nu), y_orb = r * Math.sin(nu);
    const cos_w = Math.cos(w_rad), sin_w = Math.sin(w_rad), cos_omega = Math.cos(omega_rad), sin_omega = Math.sin(omega_rad), cos_i = Math.cos(i_rad), sin_i = Math.sin(i_rad);
    let x = x_orb * (cos_w * cos_omega - sin_w * sin_omega * cos_i) - y_orb * (sin_w * cos_omega + cos_w * sin_omega * cos_i);
    let y = x_orb * (cos_w * sin_omega + sin_w * cos_omega * cos_i) + y_orb * (-sin_w * sin_omega + cos_w * cos_omega * cos_i);
    let z = x_orb * (sin_w * sin_i) + y_orb * (cos_w * sin_i);
    return { x: x / AU, y: y / AU, z: z / AU };
}

function populatePredictionSelector() {
    const selector = document.getElementById('prediction-asteroid-selector');
    selector.innerHTML = '<option value="">Selecciona un asteroide...</option>';
    const asteroidsWithElements = asteroids.filter(a => a.elements && a.name);
    if (asteroidsWithElements.length === 0) {
        selector.innerHTML = '<option value="">No hay asteroides con datos</option>';
        return;
    }
    asteroidsWithElements.forEach(asteroid => {
        const option = document.createElement('option');
        option.value = asteroid.marker.userData.id;
        option.textContent = asteroid.name;
        selector.appendChild(option);
    });
}

function visualizarInterseccion(esfera, puntos) {
    objetosVisualizacion.forEach(obj => scene.remove(obj));
    objetosVisualizacion = [];
    const meshEsfera = new THREE.Mesh(new THREE.SphereGeometry(esfera.radius, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5 }));
    meshEsfera.position.copy(esfera.center);
    scene.add(meshEsfera);
    objetosVisualizacion.push(meshEsfera);
    puntos.forEach(punto => {
        const meshPunto = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        meshPunto.position.copy(punto);
        scene.add(meshPunto);
        objetosVisualizacion.push(meshPunto);
    });
}

function analizarInterseccionOrbitaEsfera(asteroide, fechaObjetivo) {
    potentialImpactLatLng = null; // Reiniciar
    if (!asteroide?.elements || !asteroide?.orbit) return "ERROR: Datos orbitales insuficientes.";
    const posTierraUA = calcularPosicionTierra(fechaObjetivo);
    const posicionTierraMundo = new THREE.Vector3(posTierraUA.x * earthOrbitRadius, 0, posTierraUA.z * earthOrbitRadius);
    const velocities = calculateOrbitalVelocity(asteroide.elements);
    const radioCriticoKm = calculateCriticalRadius(velocities.average_km_s * 1000);
    const radioCriticoEnEscena = radioCriticoKm / (1.496e8 / 200);
    const esferaCritica = new THREE.Sphere(posicionTierraMundo, radioCriticoEnEscena);
    const puntosDeInterseccion = [];
    const posiciones = asteroide.orbit.geometry.attributes.position;
    for (let i = 0; i < posiciones.count - 1; i++) {
        const p1 = new THREE.Vector3().fromBufferAttribute(posiciones, i);
        const p2 = new THREE.Vector3().fromBufferAttribute(posiciones, i + 1);
        const direction = new THREE.Vector3().subVectors(p2, p1);
        const length = direction.length();
        const ray = new THREE.Ray(p1, direction.normalize());
        const intersectionPoint = new THREE.Vector3();
        if (ray.intersectSphere(esferaCritica, intersectionPoint) && p1.distanceTo(intersectionPoint) <= length) {
            puntosDeInterseccion.push(intersectionPoint.clone());
        }
    }
    visualizarInterseccion(esferaCritica, puntosDeInterseccion);
    if (puntosDeInterseccion.length === 0) return "‚úÖ No se encontraron colisiones potenciales.";

    const elapsedMs = fechaObjetivo.getTime() - J2000_EPOCH_MS;
    const spin = THREE.MathUtils.degToRad(280.4606) + (elapsedMs / 1000) * EARTH_ROTATION_RATE_RAD_PER_S;
    const orientacionInversa = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, spin, OBLIQUITY, 'ZYX')).invert();
    const resultados = puntosDeInterseccion.map((punto, index) => {
        const puntoAlineado = punto.clone().sub(posicionTierraMundo).applyQuaternion(orientacionInversa).normalize();
        const latDeg = THREE.MathUtils.radToDeg(Math.asin(puntoAlineado.y));
        const lonDeg = THREE.MathUtils.radToDeg(Math.atan2(puntoAlineado.z, puntoAlineado.x));
        if (index === 0) { // Guardar la primera coordenada
            potentialImpactLatLng = L.latLng(latDeg, lonDeg);
        }
        return `  Punto ${index + 1}: Lat ${latDeg.toFixed(4)}¬∞, Lon ${lonDeg.toFixed(4)}¬∞`;
    });
    return `<b>üí• ¬°POTENCIAL COLISI√ìN DETECTADA! üí•</b>\nPuntos de impacto en la superficie:\n--------------------------------------\n${resultados.join('\n')}`;
}

/* ======= INICIO Y RESIZE ======= */
function init(){
    meteorSelector = document.getElementById('meteor-selector');
    plotDistanceBtn = document.getElementById('plot-distance-btn');
    distancePlotContainer = document.getElementById('distance-plot-container');
    distancePlotCanvas = document.getElementById('distance-plot');
    
    initializeKeplerianElements();
    setupKeplerianEventListeners();
    
    plotDistanceBtn.addEventListener('click', () => {
        const selectedId = meteorSelector.value;
        if (!selectedId) return alert('Por favor selecciona un meteoro.');
        const asteroid = asteroids.find(a => a.marker?.userData?.id === selectedId);
        if (asteroid) generateDistancePlot(asteroid);
    });
    
    document.getElementById('refresh-meteor-selector').addEventListener('click', updateMeteorSelector);
    meteorSelector.addEventListener('change', (e) => updateMeteorInfo(e.target.value));
    
    document.getElementById('time-scale-selector').addEventListener('change', updateTimeScale);
    document.getElementById('time-offset-slider').addEventListener('input', updateTimeOffset);
    document.getElementById('reset-time-view').addEventListener('click', resetTimeView);
    document.getElementById('center-on-current-time').addEventListener('click', centerOnCurrentTime);
    
    setupCanvasResizing();
    document.getElementById('close-plot').addEventListener('click', () => { distancePlotContainer.style.display = 'none'; });
    
    const dateInput = document.getElementById('prediction-date');
    const asteroidSelector = document.getElementById('prediction-asteroid-selector');
    const calculateBtn = document.getElementById('prediction-calculate-btn');
    const resultsDiv = document.getElementById('prediction-results');
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    dateInput.value = now.toISOString().slice(0,16);

    calculateBtn.addEventListener('click', () => {
        const dateString = dateInput.value;
        if (!dateString) { resultsDiv.textContent = "Por favor, selecciona una fecha y hora."; return; }
        const targetDate = new Date(dateString);

        const selectedAsteroidId = asteroidSelector.value;
        if (!selectedAsteroidId) { resultsDiv.textContent = "Por favor, selecciona un asteroide."; return; }

        const asteroid = asteroids.find(a => a.marker.userData.id === selectedAsteroidId);
        if (!asteroid || !asteroid.elements) { resultsDiv.textContent = "El asteroide no tiene datos orbitales."; return; }
        
        const posTierra = calcularPosicionTierra(targetDate);
        const posAsteroide = calcularPosicionAsteroide(asteroid.elements, targetDate);
        const distanciaUA = new THREE.Vector3(posTierra.x, posTierra.y, posTierra.z).distanceTo(new THREE.Vector3(posAsteroide.x, posAsteroide.y, posAsteroide.z));
        const f = (n) => n.toFixed(4);
        
        const analisisImpacto = analizarInterseccionOrbitaEsfera(asteroid, targetDate);
        
        let simButtonHTML = '';
        if (potentialImpactLatLng) {
            simButtonHTML = `<button id="impact-sim-button">Simular Impacto en Punto de Colisi√≥n</button>`;
        } else {
            simButtonHTML = `<button id="impact-sim-button">Simular Impacto (Modo Manual)</button>`;
        }

        resultsDiv.innerHTML = `
<b>Resultados para ${targetDate.toLocaleString('es-ES')}</b>
--------------------------------------
<b>‚òÑÔ∏è ${asteroid.name} (UA):</b> x:${f(posAsteroide.x)} y:${f(posAsteroide.y)} z:${f(posAsteroide.z)}
<b>üåç Tierra (UA):</b> x:${f(posTierra.x)} y:${f(posTierra.y)} z:${f(posTierra.z)}
<b>Distancia:</b> ${f(distanciaUA)} UA (${(distanciaUA * 149.6e6).toLocaleString('es-ES',{maximumFractionDigits:0})} km)
<hr style="border-color: var(--ui-border-color); opacity: 0.5; margin: 10px 0;">
<b>An√°lisis de Impacto Orbital:</b>
<div style="margin-top: 5px; white-space: pre-wrap;">${analisisImpacto}</div>
${simButtonHTML}
`.trim();
        document.getElementById('impact-sim-button').addEventListener('click', () => launchImpactSimulator(asteroid));
    });
    
    populateBodySelector();
    selectObject(earth);
    asteroidGlowToggle.addEventListener('change', updateAllAsteroidGlows);
    updateMeteorSelector();
    populatePredictionSelector();
    animate();
    fetchNasaData();
    updateSimValues();
}
init();
addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    labelRenderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
});

</script>
</body>
</html>